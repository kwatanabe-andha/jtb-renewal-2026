(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/next/dist/shared/lib/side-effect.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return SideEffect;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
const isServer = typeof window === 'undefined';
const useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;
const useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;
function SideEffect(props) {
    const { headManager, reduceComponentsToState } = props;
    function emitChange() {
        if (headManager && headManager.mountedInstances) {
            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));
            headManager.updateHead(reduceComponentsToState(headElements));
        }
    }
    if (isServer) {
        headManager?.mountedInstances?.add(props.children);
        emitChange();
    }
    useClientOnlyLayoutEffect({
        "SideEffect.useClientOnlyLayoutEffect": ()=>{
            headManager?.mountedInstances?.add(props.children);
            return ({
                "SideEffect.useClientOnlyLayoutEffect": ()=>{
                    headManager?.mountedInstances?.delete(props.children);
                }
            })["SideEffect.useClientOnlyLayoutEffect"];
        }
    }["SideEffect.useClientOnlyLayoutEffect"]);
    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all
    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s
    // being rendered, we only trigger the method from the last one.
    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`
    // singleton in the layout effect pass, and actually trigger it in the effect pass.
    useClientOnlyLayoutEffect({
        "SideEffect.useClientOnlyLayoutEffect": ()=>{
            if (headManager) {
                headManager._pendingUpdate = emitChange;
            }
            return ({
                "SideEffect.useClientOnlyLayoutEffect": ()=>{
                    if (headManager) {
                        headManager._pendingUpdate = emitChange;
                    }
                }
            })["SideEffect.useClientOnlyLayoutEffect"];
        }
    }["SideEffect.useClientOnlyLayoutEffect"]);
    useClientOnlyEffect({
        "SideEffect.useClientOnlyEffect": ()=>{
            if (headManager && headManager._pendingUpdate) {
                headManager._pendingUpdate();
                headManager._pendingUpdate = null;
            }
            return ({
                "SideEffect.useClientOnlyEffect": ()=>{
                    if (headManager && headManager._pendingUpdate) {
                        headManager._pendingUpdate();
                        headManager._pendingUpdate = null;
                    }
                }
            })["SideEffect.useClientOnlyEffect"];
        }
    }["SideEffect.useClientOnlyEffect"]);
    return null;
} //# sourceMappingURL=side-effect.js.map
}),
"[project]/node_modules/next/dist/shared/lib/head.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    defaultHead: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    defaultHead: function() {
        return defaultHead;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _sideeffect = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/side-effect.js [app-client] (ecmascript)"));
const _headmanagercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js [app-client] (ecmascript)");
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
function defaultHead() {
    const head = [
        /*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            charSet: "utf-8"
        }, "charset"),
        /*#__PURE__*/ (0, _jsxruntime.jsx)("meta", {
            name: "viewport",
            content: "width=device-width"
        }, "viewport")
    ];
    return head;
}
function onlyReactElement(list, child) {
    // React children can be "string" or "number" in this case we ignore them for backwards compat
    if (typeof child === 'string' || typeof child === 'number') {
        return list;
    }
    // Adds support for React.Fragment
    if (child.type === _react.default.Fragment) {
        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{
            if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
                return fragmentList;
            }
            return fragmentList.concat(fragmentChild);
        }, []));
    }
    return list.concat(child);
}
const METATYPES = [
    'name',
    'httpEquiv',
    'charSet',
    'itemProp'
];
/*
 returns a function for filtering head child elements
 which shouldn't be duplicated, like <title/>
 Also adds support for deduplicated `key` properties
*/ function unique() {
    const keys = new Set();
    const tags = new Set();
    const metaTypes = new Set();
    const metaCategories = {};
    return (h)=>{
        let isUnique = true;
        let hasKey = false;
        if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
            hasKey = true;
            const key = h.key.slice(h.key.indexOf('$') + 1);
            if (keys.has(key)) {
                isUnique = false;
            } else {
                keys.add(key);
            }
        }
        // eslint-disable-next-line default-case
        switch(h.type){
            case 'title':
            case 'base':
                if (tags.has(h.type)) {
                    isUnique = false;
                } else {
                    tags.add(h.type);
                }
                break;
            case 'meta':
                for(let i = 0, len = METATYPES.length; i < len; i++){
                    const metatype = METATYPES[i];
                    if (!h.props.hasOwnProperty(metatype)) continue;
                    if (metatype === 'charSet') {
                        if (metaTypes.has(metatype)) {
                            isUnique = false;
                        } else {
                            metaTypes.add(metatype);
                        }
                    } else {
                        const category = h.props[metatype];
                        const categories = metaCategories[metatype] || new Set();
                        if ((metatype !== 'name' || !hasKey) && categories.has(category)) {
                            isUnique = false;
                        } else {
                            categories.add(category);
                            metaCategories[metatype] = categories;
                        }
                    }
                }
                break;
        }
        return isUnique;
    };
}
/**
 *
 * @param headChildrenElements List of children of <Head>
 */ function reduceComponents(headChildrenElements) {
    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead().reverse()).filter(unique()).reverse().map((c, i)=>{
        const key = c.key || i;
        if ("TURBOPACK compile-time truthy", 1) {
            // omit JSON-LD structured data snippets from the warning
            if (c.type === 'script' && c.props['type'] !== 'application/ld+json') {
                const srcMessage = c.props['src'] ? `<script> tag with src="${c.props['src']}"` : `inline <script>`;
                (0, _warnonce.warnOnce)(`Do not add <script> tags using next/head (see ${srcMessage}). Use next/script instead. \nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component`);
            } else if (c.type === 'link' && c.props['rel'] === 'stylesheet') {
                (0, _warnonce.warnOnce)(`Do not add stylesheets using next/head (see <link rel="stylesheet"> tag with href="${c.props['href']}"). Use Document instead. \nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component`);
            }
        }
        return /*#__PURE__*/ _react.default.cloneElement(c, {
            key
        });
    });
}
/**
 * This component injects elements to `<head>` of your page.
 * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
 */ function Head({ children }) {
    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {
        reduceComponentsToState: reduceComponents,
        headManager: headManager,
        children: children
    });
}
const _default = Head;
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=head.js.map
}),
"[project]/node_modules/next/dist/shared/lib/image-blur-svg.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * A shared function, used on both client and server, to generate a SVG blur placeholder.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getImageBlurSvg", {
    enumerable: true,
    get: function() {
        return getImageBlurSvg;
    }
});
function getImageBlurSvg({ widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit }) {
    const std = 20;
    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;
    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;
    const viewBox = svgWidth && svgHeight ? `viewBox='0 0 ${svgWidth} ${svgHeight}'` : '';
    const preserveAspectRatio = viewBox ? 'none' : objectFit === 'contain' ? 'xMidYMid' : objectFit === 'cover' ? 'xMidYMid slice' : 'none';
    return `%3Csvg xmlns='http://www.w3.org/2000/svg' ${viewBox}%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='${std}'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='${std}'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='${preserveAspectRatio}' style='filter: url(%23b);' href='${blurDataURL}'/%3E%3C/svg%3E`;
} //# sourceMappingURL=image-blur-svg.js.map
}),
"[project]/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    VALID_LOADERS: null,
    imageConfigDefault: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    VALID_LOADERS: function() {
        return VALID_LOADERS;
    },
    imageConfigDefault: function() {
        return imageConfigDefault;
    }
});
const VALID_LOADERS = [
    'default',
    'imgix',
    'cloudinary',
    'akamai',
    'custom'
];
const imageConfigDefault = {
    deviceSizes: [
        640,
        750,
        828,
        1080,
        1200,
        1920,
        2048,
        3840
    ],
    imageSizes: [
        32,
        48,
        64,
        96,
        128,
        256,
        384
    ],
    path: '/_next/image',
    loader: 'default',
    loaderFile: '',
    /**
   * @deprecated Use `remotePatterns` instead to protect your application from malicious users.
   */ domains: [],
    disableStaticImages: false,
    minimumCacheTTL: 14400,
    formats: [
        'image/webp'
    ],
    maximumRedirects: 3,
    dangerouslyAllowLocalIP: false,
    dangerouslyAllowSVG: false,
    contentSecurityPolicy: `script-src 'none'; frame-src 'none'; sandbox;`,
    contentDispositionType: 'attachment',
    localPatterns: undefined,
    remotePatterns: [],
    qualities: [
        75
    ],
    unoptimized: false
}; //# sourceMappingURL=image-config.js.map
}),
"[project]/node_modules/next/dist/shared/lib/get-img-props.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getImgProps", {
    enumerable: true,
    get: function() {
        return getImgProps;
    }
});
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
const _imageblursvg = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-blur-svg.js [app-client] (ecmascript)");
const _imageconfig = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)");
const VALID_LOADING_VALUES = [
    'lazy',
    'eager',
    undefined
];
// Object-fit values that are not valid background-size values
const INVALID_BACKGROUND_SIZE_VALUES = [
    '-moz-initial',
    'fill',
    'none',
    'scale-down',
    undefined
];
function isStaticRequire(src) {
    return src.default !== undefined;
}
function isStaticImageData(src) {
    return src.src !== undefined;
}
function isStaticImport(src) {
    return !!src && typeof src === 'object' && (isStaticRequire(src) || isStaticImageData(src));
}
const allImgs = new Map();
let perfObserver;
function getInt(x) {
    if (typeof x === 'undefined') {
        return x;
    }
    if (typeof x === 'number') {
        return Number.isFinite(x) ? x : NaN;
    }
    if (typeof x === 'string' && /^[0-9]+$/.test(x)) {
        return parseInt(x, 10);
    }
    return NaN;
}
function getWidths({ deviceSizes, allSizes }, width, sizes) {
    if (sizes) {
        // Find all the "vw" percent sizes used in the sizes prop
        const viewportWidthRe = /(^|\s)(1?\d?\d)vw/g;
        const percentSizes = [];
        for(let match; match = viewportWidthRe.exec(sizes); match){
            percentSizes.push(parseInt(match[2]));
        }
        if (percentSizes.length) {
            const smallestRatio = Math.min(...percentSizes) * 0.01;
            return {
                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),
                kind: 'w'
            };
        }
        return {
            widths: allSizes,
            kind: 'w'
        };
    }
    if (typeof width !== 'number') {
        return {
            widths: deviceSizes,
            kind: 'w'
        };
    }
    const widths = [
        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and
        // > blue colors. Showing a 3x resolution image in the app vs a 2x
        // > resolution image will be visually the same, though the 3x image
        // > takes significantly more data. Even true 3x resolution screens are
        // > wasteful as the human eye cannot see that level of detail without
        // > something like a magnifying glass.
        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html
        [
            width,
            width * 2 /*, width * 3*/ 
        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))
    ];
    return {
        widths,
        kind: 'x'
    };
}
function generateImgAttrs({ config, src, unoptimized, width, quality, sizes, loader }) {
    if (unoptimized) {
        return {
            src,
            srcSet: undefined,
            sizes: undefined
        };
    }
    const { widths, kind } = getWidths(config, width, sizes);
    const last = widths.length - 1;
    return {
        sizes: !sizes && kind === 'w' ? '100vw' : sizes,
        srcSet: widths.map((w, i)=>`${loader({
                config,
                src,
                quality,
                width: w
            })} ${kind === 'w' ? w : i + 1}${kind}`).join(', '),
        // It's intended to keep `src` the last attribute because React updates
        // attributes in order. If we keep `src` the first one, Safari will
        // immediately start to fetch `src`, before `sizes` and `srcSet` are even
        // updated by React. That causes multiple unnecessary requests if `srcSet`
        // and `sizes` are defined.
        // This bug cannot be reproduced in Chrome or Firefox.
        src: loader({
            config,
            src,
            quality,
            width: widths[last]
        })
    };
}
function getImgProps({ src, sizes, unoptimized = false, priority = false, preload = false, loading, className, quality, width, height, fill = false, style, overrideSrc, onLoad, onLoadingComplete, placeholder = 'empty', blurDataURL, fetchPriority, decoding = 'async', layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest }, _state) {
    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;
    let config;
    let c = imgConf || _imageconfig.imageConfigDefault;
    if ('allSizes' in c) {
        config = c;
    } else {
        const allSizes = [
            ...c.deviceSizes,
            ...c.imageSizes
        ].sort((a, b)=>a - b);
        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);
        const qualities = c.qualities?.sort((a, b)=>a - b);
        config = {
            ...c,
            allSizes,
            deviceSizes,
            qualities
        };
    }
    if (typeof defaultLoader === 'undefined') {
        throw Object.defineProperty(new Error('images.loaderFile detected but the file is missing default export.\nRead more: https://nextjs.org/docs/messages/invalid-images-config'), "__NEXT_ERROR_CODE", {
            value: "E163",
            enumerable: false,
            configurable: true
        });
    }
    let loader = rest.loader || defaultLoader;
    // Remove property so it's not spread on <img> element
    delete rest.loader;
    delete rest.srcSet;
    // This special value indicates that the user
    // didn't define a "loader" prop or "loader" config.
    const isDefaultLoader = '__next_img_default' in loader;
    if (isDefaultLoader) {
        if (config.loader === 'custom') {
            throw Object.defineProperty(new Error(`Image with src "${src}" is missing "loader" prop.` + `\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader`), "__NEXT_ERROR_CODE", {
                value: "E252",
                enumerable: false,
                configurable: true
            });
        }
    } else {
        // The user defined a "loader" prop or config.
        // Since the config object is internal only, we
        // must not pass it to the user-defined "loader".
        const customImageLoader = loader;
        loader = (obj)=>{
            const { config: _, ...opts } = obj;
            return customImageLoader(opts);
        };
    }
    if (layout) {
        if (layout === 'fill') {
            fill = true;
        }
        const layoutToStyle = {
            intrinsic: {
                maxWidth: '100%',
                height: 'auto'
            },
            responsive: {
                width: '100%',
                height: 'auto'
            }
        };
        const layoutToSizes = {
            responsive: '100vw',
            fill: '100vw'
        };
        const layoutStyle = layoutToStyle[layout];
        if (layoutStyle) {
            style = {
                ...style,
                ...layoutStyle
            };
        }
        const layoutSizes = layoutToSizes[layout];
        if (layoutSizes && !sizes) {
            sizes = layoutSizes;
        }
    }
    let staticSrc = '';
    let widthInt = getInt(width);
    let heightInt = getInt(height);
    let blurWidth;
    let blurHeight;
    if (isStaticImport(src)) {
        const staticImageData = isStaticRequire(src) ? src.default : src;
        if (!staticImageData.src) {
            throw Object.defineProperty(new Error(`An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received ${JSON.stringify(staticImageData)}`), "__NEXT_ERROR_CODE", {
                value: "E460",
                enumerable: false,
                configurable: true
            });
        }
        if (!staticImageData.height || !staticImageData.width) {
            throw Object.defineProperty(new Error(`An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received ${JSON.stringify(staticImageData)}`), "__NEXT_ERROR_CODE", {
                value: "E48",
                enumerable: false,
                configurable: true
            });
        }
        blurWidth = staticImageData.blurWidth;
        blurHeight = staticImageData.blurHeight;
        blurDataURL = blurDataURL || staticImageData.blurDataURL;
        staticSrc = staticImageData.src;
        if (!fill) {
            if (!widthInt && !heightInt) {
                widthInt = staticImageData.width;
                heightInt = staticImageData.height;
            } else if (widthInt && !heightInt) {
                const ratio = widthInt / staticImageData.width;
                heightInt = Math.round(staticImageData.height * ratio);
            } else if (!widthInt && heightInt) {
                const ratio = heightInt / staticImageData.height;
                widthInt = Math.round(staticImageData.width * ratio);
            }
        }
    }
    src = typeof src === 'string' ? src : staticSrc;
    let isLazy = !priority && !preload && (loading === 'lazy' || typeof loading === 'undefined');
    if (!src || src.startsWith('data:') || src.startsWith('blob:')) {
        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
        unoptimized = true;
        isLazy = false;
    }
    if (config.unoptimized) {
        unoptimized = true;
    }
    if (isDefaultLoader && !config.dangerouslyAllowSVG && src.split('?', 1)[0].endsWith('.svg')) {
        // Special case to make svg serve as-is to avoid proxying
        // through the built-in Image Optimization API.
        unoptimized = true;
    }
    const qualityInt = getInt(quality);
    if ("TURBOPACK compile-time truthy", 1) {
        if (config.output === 'export' && isDefaultLoader && !unoptimized) {
            throw Object.defineProperty(new Error(`Image Optimization using the default loader is not compatible with \`{ output: 'export' }\`.
  Possible solutions:
    - Remove \`{ output: 'export' }\` and run "next start" to run server mode including the Image Optimization API.
    - Configure \`{ images: { unoptimized: true } }\` in \`next.config.js\` to disable the Image Optimization API.
  Read more: https://nextjs.org/docs/messages/export-image-api`), "__NEXT_ERROR_CODE", {
                value: "E500",
                enumerable: false,
                configurable: true
            });
        }
        if (!src) {
            // React doesn't show the stack trace and there's
            // no `src` to help identify which image, so we
            // instead console.error(ref) during mount.
            unoptimized = true;
        } else {
            if (fill) {
                if (width) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has both "width" and "fill" properties. Only one should be used.`), "__NEXT_ERROR_CODE", {
                        value: "E96",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (height) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has both "height" and "fill" properties. Only one should be used.`), "__NEXT_ERROR_CODE", {
                        value: "E115",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (style?.position && style.position !== 'absolute') {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has both "fill" and "style.position" properties. Images with "fill" always use position absolute - it cannot be modified.`), "__NEXT_ERROR_CODE", {
                        value: "E216",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (style?.width && style.width !== '100%') {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has both "fill" and "style.width" properties. Images with "fill" always use width 100% - it cannot be modified.`), "__NEXT_ERROR_CODE", {
                        value: "E73",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (style?.height && style.height !== '100%') {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has both "fill" and "style.height" properties. Images with "fill" always use height 100% - it cannot be modified.`), "__NEXT_ERROR_CODE", {
                        value: "E404",
                        enumerable: false,
                        configurable: true
                    });
                }
            } else {
                if (typeof widthInt === 'undefined') {
                    throw Object.defineProperty(new Error(`Image with src "${src}" is missing required "width" property.`), "__NEXT_ERROR_CODE", {
                        value: "E451",
                        enumerable: false,
                        configurable: true
                    });
                } else if (isNaN(widthInt)) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has invalid "width" property. Expected a numeric value in pixels but received "${width}".`), "__NEXT_ERROR_CODE", {
                        value: "E66",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (typeof heightInt === 'undefined') {
                    throw Object.defineProperty(new Error(`Image with src "${src}" is missing required "height" property.`), "__NEXT_ERROR_CODE", {
                        value: "E397",
                        enumerable: false,
                        configurable: true
                    });
                } else if (isNaN(heightInt)) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" has invalid "height" property. Expected a numeric value in pixels but received "${height}".`), "__NEXT_ERROR_CODE", {
                        value: "E444",
                        enumerable: false,
                        configurable: true
                    });
                }
                // eslint-disable-next-line no-control-regex
                if (/^[\x00-\x20]/.test(src)) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" cannot start with a space or control character. Use src.trimStart() to remove it or encodeURIComponent(src) to keep it.`), "__NEXT_ERROR_CODE", {
                        value: "E176",
                        enumerable: false,
                        configurable: true
                    });
                }
                // eslint-disable-next-line no-control-regex
                if (/[\x00-\x20]$/.test(src)) {
                    throw Object.defineProperty(new Error(`Image with src "${src}" cannot end with a space or control character. Use src.trimEnd() to remove it or encodeURIComponent(src) to keep it.`), "__NEXT_ERROR_CODE", {
                        value: "E21",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
        if (!VALID_LOADING_VALUES.includes(loading)) {
            throw Object.defineProperty(new Error(`Image with src "${src}" has invalid "loading" property. Provided "${loading}" should be one of ${VALID_LOADING_VALUES.map(String).join(',')}.`), "__NEXT_ERROR_CODE", {
                value: "E357",
                enumerable: false,
                configurable: true
            });
        }
        if (priority && loading === 'lazy') {
            throw Object.defineProperty(new Error(`Image with src "${src}" has both "priority" and "loading='lazy'" properties. Only one should be used.`), "__NEXT_ERROR_CODE", {
                value: "E218",
                enumerable: false,
                configurable: true
            });
        }
        if (preload && loading === 'lazy') {
            throw Object.defineProperty(new Error(`Image with src "${src}" has both "preload" and "loading='lazy'" properties. Only one should be used.`), "__NEXT_ERROR_CODE", {
                value: "E803",
                enumerable: false,
                configurable: true
            });
        }
        if (preload && priority) {
            throw Object.defineProperty(new Error(`Image with src "${src}" has both "preload" and "priority" properties. Only "preload" should be used.`), "__NEXT_ERROR_CODE", {
                value: "E802",
                enumerable: false,
                configurable: true
            });
        }
        if (placeholder !== 'empty' && placeholder !== 'blur' && !placeholder.startsWith('data:image/')) {
            throw Object.defineProperty(new Error(`Image with src "${src}" has invalid "placeholder" property "${placeholder}".`), "__NEXT_ERROR_CODE", {
                value: "E431",
                enumerable: false,
                configurable: true
            });
        }
        if (placeholder !== 'empty') {
            if (widthInt && heightInt && widthInt * heightInt < 1600) {
                (0, _warnonce.warnOnce)(`Image with src "${src}" is smaller than 40x40. Consider removing the "placeholder" property to improve performance.`);
            }
        }
        if (qualityInt && config.qualities && !config.qualities.includes(qualityInt)) {
            (0, _warnonce.warnOnce)(`Image with src "${src}" is using quality "${qualityInt}" which is not configured in images.qualities [${config.qualities.join(', ')}]. Please update your config to [${[
                ...config.qualities,
                qualityInt
            ].sort().join(', ')}].` + `\nRead more: https://nextjs.org/docs/messages/next-image-unconfigured-qualities`);
        }
        if (placeholder === 'blur' && !blurDataURL) {
            const VALID_BLUR_EXT = [
                'jpeg',
                'png',
                'webp',
                'avif'
            ] // should match next-image-loader
            ;
            throw Object.defineProperty(new Error(`Image with src "${src}" has "placeholder='blur'" property but is missing the "blurDataURL" property.
        Possible solutions:
          - Add a "blurDataURL" property, the contents should be a small Data URL to represent the image
          - Change the "src" property to a static import with one of the supported file types: ${VALID_BLUR_EXT.join(',')} (animated images not supported)
          - Remove the "placeholder" property, effectively no blur effect
        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url`), "__NEXT_ERROR_CODE", {
                value: "E371",
                enumerable: false,
                configurable: true
            });
        }
        if ('ref' in rest) {
            (0, _warnonce.warnOnce)(`Image with src "${src}" is using unsupported "ref" property. Consider using the "onLoad" property instead.`);
        }
        if (!unoptimized && !isDefaultLoader) {
            const urlStr = loader({
                config,
                src,
                width: widthInt || 400,
                quality: qualityInt || 75
            });
            let url;
            try {
                url = new URL(urlStr);
            } catch (err) {}
            if (urlStr === src || url && url.pathname === src && !url.search) {
                (0, _warnonce.warnOnce)(`Image with src "${src}" has a "loader" property that does not implement width. Please implement it or use the "unoptimized" property instead.` + `\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width`);
            }
        }
        if (onLoadingComplete) {
            (0, _warnonce.warnOnce)(`Image with src "${src}" is using deprecated "onLoadingComplete" property. Please use the "onLoad" property instead.`);
        }
        for (const [legacyKey, legacyValue] of Object.entries({
            layout,
            objectFit,
            objectPosition,
            lazyBoundary,
            lazyRoot
        })){
            if (legacyValue) {
                (0, _warnonce.warnOnce)(`Image with src "${src}" has legacy prop "${legacyKey}". Did you forget to run the codemod?` + `\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13`);
            }
        }
        if (typeof window !== 'undefined' && !perfObserver && window.PerformanceObserver) {
            perfObserver = new PerformanceObserver((entryList)=>{
                for (const entry of entryList.getEntries()){
                    // @ts-ignore - missing "LargestContentfulPaint" class with "element" prop
                    const imgSrc = entry?.element?.src || '';
                    const lcpImage = allImgs.get(imgSrc);
                    if (lcpImage && lcpImage.loading === 'lazy' && lcpImage.placeholder === 'empty' && !lcpImage.src.startsWith('data:') && !lcpImage.src.startsWith('blob:')) {
                        // https://web.dev/lcp/#measure-lcp-in-javascript
                        (0, _warnonce.warnOnce)(`Image with src "${lcpImage.src}" was detected as the Largest Contentful Paint (LCP). Please add the \`loading="eager"\` property if this image is above the fold.` + `\nRead more: https://nextjs.org/docs/app/api-reference/components/image#loading`);
                    }
                }
            });
            try {
                perfObserver.observe({
                    type: 'largest-contentful-paint',
                    buffered: true
                });
            } catch (err) {
                // Log error but don't crash the app
                console.error(err);
            }
        }
    }
    const imgStyle = Object.assign(fill ? {
        position: 'absolute',
        height: '100%',
        width: '100%',
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        objectFit,
        objectPosition
    } : {}, showAltText ? {} : {
        color: 'transparent'
    }, style);
    const backgroundImage = !blurComplete && placeholder !== 'empty' ? placeholder === 'blur' ? `url("data:image/svg+xml;charset=utf-8,${(0, _imageblursvg.getImageBlurSvg)({
        widthInt,
        heightInt,
        blurWidth,
        blurHeight,
        blurDataURL: blurDataURL || '',
        objectFit: imgStyle.objectFit
    })}")` : `url("${placeholder}")` // assume `data:image/`
     : null;
    const backgroundSize = !INVALID_BACKGROUND_SIZE_VALUES.includes(imgStyle.objectFit) ? imgStyle.objectFit : imgStyle.objectFit === 'fill' ? '100% 100%' // the background-size equivalent of `fill`
     : 'cover';
    let placeholderStyle = backgroundImage ? {
        backgroundSize,
        backgroundPosition: imgStyle.objectPosition || '50% 50%',
        backgroundRepeat: 'no-repeat',
        backgroundImage
    } : {};
    if ("TURBOPACK compile-time truthy", 1) {
        if (placeholderStyle.backgroundImage && placeholder === 'blur' && blurDataURL?.startsWith('/')) {
            // During `next dev`, we don't want to generate blur placeholders with webpack
            // because it can delay starting the dev server. Instead, `next-image-loader.js`
            // will inline a special url to lazily generate the blur placeholder at request time.
            placeholderStyle.backgroundImage = `url("${blurDataURL}")`;
        }
    }
    const imgAttributes = generateImgAttrs({
        config,
        src,
        unoptimized,
        width: widthInt,
        quality: qualityInt,
        sizes,
        loader
    });
    const loadingFinal = isLazy ? 'lazy' : loading;
    if ("TURBOPACK compile-time truthy", 1) {
        if (typeof window !== 'undefined') {
            let fullUrl;
            try {
                fullUrl = new URL(imgAttributes.src);
            } catch (e) {
                fullUrl = new URL(imgAttributes.src, window.location.href);
            }
            allImgs.set(fullUrl.href, {
                src,
                loading: loadingFinal,
                placeholder
            });
        }
    }
    const props = {
        ...rest,
        loading: loadingFinal,
        fetchPriority,
        width: widthInt,
        height: heightInt,
        decoding,
        className,
        style: {
            ...imgStyle,
            ...placeholderStyle
        },
        sizes: imgAttributes.sizes,
        srcSet: imgAttributes.srcSet,
        src: overrideSrc || imgAttributes.src
    };
    const meta = {
        unoptimized,
        preload: preload || priority,
        placeholder,
        fill
    };
    return {
        props,
        meta
    };
} //# sourceMappingURL=get-img-props.js.map
}),
"[project]/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ImageConfigContext", {
    enumerable: true,
    get: function() {
        return ImageConfigContext;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _imageconfig = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)");
const ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);
if ("TURBOPACK compile-time truthy", 1) {
    ImageConfigContext.displayName = 'ImageConfigContext';
} //# sourceMappingURL=image-config-context.shared-runtime.js.map
}),
"[project]/node_modules/next/dist/shared/lib/router-context.shared-runtime.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RouterContext", {
    enumerable: true,
    get: function() {
        return RouterContext;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const RouterContext = _react.default.createContext(null);
if ("TURBOPACK compile-time truthy", 1) {
    RouterContext.displayName = 'RouterContext';
} //# sourceMappingURL=router-context.shared-runtime.js.map
}),
"[project]/node_modules/next/dist/shared/lib/find-closest-quality.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "findClosestQuality", {
    enumerable: true,
    get: function() {
        return findClosestQuality;
    }
});
function findClosestQuality(quality, config) {
    const q = quality || 75;
    if (!config?.qualities?.length) {
        return q;
    }
    return config.qualities.reduce((prev, cur)=>Math.abs(cur - q) < Math.abs(prev - q) ? cur : prev, 0);
} //# sourceMappingURL=find-closest-quality.js.map
}),
"[project]/node_modules/next/dist/compiled/picomatch/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
(()=>{
    "use strict";
    var t = {
        170: (t, e, u)=>{
            const n = u(510);
            const isWindows = ()=>{
                if (typeof navigator !== "undefined" && navigator.platform) {
                    const t = navigator.platform.toLowerCase();
                    return t === "win32" || t === "windows";
                }
                if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform) {
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === "win32";
                }
                return false;
            };
            function picomatch(t, e, u = false) {
                if (e && (e.windows === null || e.windows === undefined)) {
                    e = {
                        ...e,
                        windows: isWindows()
                    };
                }
                return n(t, e, u);
            }
            Object.assign(picomatch, n);
            t.exports = picomatch;
        },
        154: (t)=>{
            const e = "\\\\/";
            const u = `[^${e}]`;
            const n = "\\.";
            const o = "\\+";
            const s = "\\?";
            const r = "\\/";
            const a = "(?=.)";
            const i = "[^/]";
            const c = `(?:${r}|$)`;
            const p = `(?:^|${r})`;
            const l = `${n}{1,2}${c}`;
            const f = `(?!${n})`;
            const A = `(?!${p}${l})`;
            const _ = `(?!${n}{0,1}${c})`;
            const R = `(?!${l})`;
            const E = `[^.${r}]`;
            const h = `${i}*?`;
            const g = "/";
            const b = {
                DOT_LITERAL: n,
                PLUS_LITERAL: o,
                QMARK_LITERAL: s,
                SLASH_LITERAL: r,
                ONE_CHAR: a,
                QMARK: i,
                END_ANCHOR: c,
                DOTS_SLASH: l,
                NO_DOT: f,
                NO_DOTS: A,
                NO_DOT_SLASH: _,
                NO_DOTS_SLASH: R,
                QMARK_NO_DOT: E,
                STAR: h,
                START_ANCHOR: p,
                SEP: g
            };
            const C = {
                ...b,
                SLASH_LITERAL: `[${e}]`,
                QMARK: u,
                STAR: `${u}*?`,
                DOTS_SLASH: `${n}{1,2}(?:[${e}]|$)`,
                NO_DOT: `(?!${n})`,
                NO_DOTS: `(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,
                NO_DOT_SLASH: `(?!${n}{0,1}(?:[${e}]|$))`,
                NO_DOTS_SLASH: `(?!${n}{1,2}(?:[${e}]|$))`,
                QMARK_NO_DOT: `[^.${e}]`,
                START_ANCHOR: `(?:^|[${e}])`,
                END_ANCHOR: `(?:[${e}]|$)`,
                SEP: "\\"
            };
            const y = {
                alnum: "a-zA-Z0-9",
                alpha: "a-zA-Z",
                ascii: "\\x00-\\x7F",
                blank: " \\t",
                cntrl: "\\x00-\\x1F\\x7F",
                digit: "0-9",
                graph: "\\x21-\\x7E",
                lower: "a-z",
                print: "\\x20-\\x7E ",
                punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
                space: " \\t\\r\\n\\v\\f",
                upper: "A-Z",
                word: "A-Za-z0-9_",
                xdigit: "A-Fa-f0-9"
            };
            t.exports = {
                MAX_LENGTH: 1024 * 64,
                POSIX_REGEX_SOURCE: y,
                REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
                REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
                REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
                REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
                REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
                REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
                REPLACEMENTS: {
                    "***": "*",
                    "**/**": "**",
                    "**/**/**": "**"
                },
                CHAR_0: 48,
                CHAR_9: 57,
                CHAR_UPPERCASE_A: 65,
                CHAR_LOWERCASE_A: 97,
                CHAR_UPPERCASE_Z: 90,
                CHAR_LOWERCASE_Z: 122,
                CHAR_LEFT_PARENTHESES: 40,
                CHAR_RIGHT_PARENTHESES: 41,
                CHAR_ASTERISK: 42,
                CHAR_AMPERSAND: 38,
                CHAR_AT: 64,
                CHAR_BACKWARD_SLASH: 92,
                CHAR_CARRIAGE_RETURN: 13,
                CHAR_CIRCUMFLEX_ACCENT: 94,
                CHAR_COLON: 58,
                CHAR_COMMA: 44,
                CHAR_DOT: 46,
                CHAR_DOUBLE_QUOTE: 34,
                CHAR_EQUAL: 61,
                CHAR_EXCLAMATION_MARK: 33,
                CHAR_FORM_FEED: 12,
                CHAR_FORWARD_SLASH: 47,
                CHAR_GRAVE_ACCENT: 96,
                CHAR_HASH: 35,
                CHAR_HYPHEN_MINUS: 45,
                CHAR_LEFT_ANGLE_BRACKET: 60,
                CHAR_LEFT_CURLY_BRACE: 123,
                CHAR_LEFT_SQUARE_BRACKET: 91,
                CHAR_LINE_FEED: 10,
                CHAR_NO_BREAK_SPACE: 160,
                CHAR_PERCENT: 37,
                CHAR_PLUS: 43,
                CHAR_QUESTION_MARK: 63,
                CHAR_RIGHT_ANGLE_BRACKET: 62,
                CHAR_RIGHT_CURLY_BRACE: 125,
                CHAR_RIGHT_SQUARE_BRACKET: 93,
                CHAR_SEMICOLON: 59,
                CHAR_SINGLE_QUOTE: 39,
                CHAR_SPACE: 32,
                CHAR_TAB: 9,
                CHAR_UNDERSCORE: 95,
                CHAR_VERTICAL_LINE: 124,
                CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
                extglobChars (t) {
                    return {
                        "!": {
                            type: "negate",
                            open: "(?:(?!(?:",
                            close: `))${t.STAR})`
                        },
                        "?": {
                            type: "qmark",
                            open: "(?:",
                            close: ")?"
                        },
                        "+": {
                            type: "plus",
                            open: "(?:",
                            close: ")+"
                        },
                        "*": {
                            type: "star",
                            open: "(?:",
                            close: ")*"
                        },
                        "@": {
                            type: "at",
                            open: "(?:",
                            close: ")"
                        }
                    };
                },
                globChars (t) {
                    return t === true ? C : b;
                }
            };
        },
        697: (t, e, u)=>{
            const n = u(154);
            const o = u(96);
            const { MAX_LENGTH: s, POSIX_REGEX_SOURCE: r, REGEX_NON_SPECIAL_CHARS: a, REGEX_SPECIAL_CHARS_BACKREF: i, REPLACEMENTS: c } = n;
            const expandRange = (t, e)=>{
                if (typeof e.expandRange === "function") {
                    return e.expandRange(...t, e);
                }
                t.sort();
                const u = `[${t.join("-")}]`;
                try {
                    new RegExp(u);
                } catch (e) {
                    return t.map((t)=>o.escapeRegex(t)).join("..");
                }
                return u;
            };
            const syntaxError = (t, e)=>`Missing ${t}: "${e}" - use "\\\\${e}" to match literal characters`;
            const parse = (t, e)=>{
                if (typeof t !== "string") {
                    throw new TypeError("Expected a string");
                }
                t = c[t] || t;
                const u = {
                    ...e
                };
                const p = typeof u.maxLength === "number" ? Math.min(s, u.maxLength) : s;
                let l = t.length;
                if (l > p) {
                    throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`);
                }
                const f = {
                    type: "bos",
                    value: "",
                    output: u.prepend || ""
                };
                const A = [
                    f
                ];
                const _ = u.capture ? "" : "?:";
                const R = n.globChars(u.windows);
                const E = n.extglobChars(R);
                const { DOT_LITERAL: h, PLUS_LITERAL: g, SLASH_LITERAL: b, ONE_CHAR: C, DOTS_SLASH: y, NO_DOT: $, NO_DOT_SLASH: x, NO_DOTS_SLASH: S, QMARK: H, QMARK_NO_DOT: v, STAR: d, START_ANCHOR: L } = R;
                const globstar = (t)=>`(${_}(?:(?!${L}${t.dot ? y : h}).)*?)`;
                const T = u.dot ? "" : $;
                const O = u.dot ? H : v;
                let k = u.bash === true ? globstar(u) : d;
                if (u.capture) {
                    k = `(${k})`;
                }
                if (typeof u.noext === "boolean") {
                    u.noextglob = u.noext;
                }
                const m = {
                    input: t,
                    index: -1,
                    start: 0,
                    dot: u.dot === true,
                    consumed: "",
                    output: "",
                    prefix: "",
                    backtrack: false,
                    negated: false,
                    brackets: 0,
                    braces: 0,
                    parens: 0,
                    quotes: 0,
                    globstar: false,
                    tokens: A
                };
                t = o.removePrefix(t, m);
                l = t.length;
                const w = [];
                const N = [];
                const I = [];
                let B = f;
                let G;
                const eos = ()=>m.index === l - 1;
                const D = m.peek = (e = 1)=>t[m.index + e];
                const M = m.advance = ()=>t[++m.index] || "";
                const remaining = ()=>t.slice(m.index + 1);
                const consume = (t = "", e = 0)=>{
                    m.consumed += t;
                    m.index += e;
                };
                const append = (t)=>{
                    m.output += t.output != null ? t.output : t.value;
                    consume(t.value);
                };
                const negate = ()=>{
                    let t = 1;
                    while(D() === "!" && (D(2) !== "(" || D(3) === "?")){
                        M();
                        m.start++;
                        t++;
                    }
                    if (t % 2 === 0) {
                        return false;
                    }
                    m.negated = true;
                    m.start++;
                    return true;
                };
                const increment = (t)=>{
                    m[t]++;
                    I.push(t);
                };
                const decrement = (t)=>{
                    m[t]--;
                    I.pop();
                };
                const push = (t)=>{
                    if (B.type === "globstar") {
                        const e = m.braces > 0 && (t.type === "comma" || t.type === "brace");
                        const u = t.extglob === true || w.length && (t.type === "pipe" || t.type === "paren");
                        if (t.type !== "slash" && t.type !== "paren" && !e && !u) {
                            m.output = m.output.slice(0, -B.output.length);
                            B.type = "star";
                            B.value = "*";
                            B.output = k;
                            m.output += B.output;
                        }
                    }
                    if (w.length && t.type !== "paren") {
                        w[w.length - 1].inner += t.value;
                    }
                    if (t.value || t.output) append(t);
                    if (B && B.type === "text" && t.type === "text") {
                        B.output = (B.output || B.value) + t.value;
                        B.value += t.value;
                        return;
                    }
                    t.prev = B;
                    A.push(t);
                    B = t;
                };
                const extglobOpen = (t, e)=>{
                    const n = {
                        ...E[e],
                        conditions: 1,
                        inner: ""
                    };
                    n.prev = B;
                    n.parens = m.parens;
                    n.output = m.output;
                    const o = (u.capture ? "(" : "") + n.open;
                    increment("parens");
                    push({
                        type: t,
                        value: e,
                        output: m.output ? "" : C
                    });
                    push({
                        type: "paren",
                        extglob: true,
                        value: M(),
                        output: o
                    });
                    w.push(n);
                };
                const extglobClose = (t)=>{
                    let n = t.close + (u.capture ? ")" : "");
                    let o;
                    if (t.type === "negate") {
                        let s = k;
                        if (t.inner && t.inner.length > 1 && t.inner.includes("/")) {
                            s = globstar(u);
                        }
                        if (s !== k || eos() || /^\)+$/.test(remaining())) {
                            n = t.close = `)$))${s}`;
                        }
                        if (t.inner.includes("*") && (o = remaining()) && /^\.[^\\/.]+$/.test(o)) {
                            const u = parse(o, {
                                ...e,
                                fastpaths: false
                            }).output;
                            n = t.close = `)${u})${s})`;
                        }
                        if (t.prev.type === "bos") {
                            m.negatedExtglob = true;
                        }
                    }
                    push({
                        type: "paren",
                        extglob: true,
                        value: G,
                        output: n
                    });
                    decrement("parens");
                };
                if (u.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(t)) {
                    let n = false;
                    let s = t.replace(i, (t, e, u, o, s, r)=>{
                        if (o === "\\") {
                            n = true;
                            return t;
                        }
                        if (o === "?") {
                            if (e) {
                                return e + o + (s ? H.repeat(s.length) : "");
                            }
                            if (r === 0) {
                                return O + (s ? H.repeat(s.length) : "");
                            }
                            return H.repeat(u.length);
                        }
                        if (o === ".") {
                            return h.repeat(u.length);
                        }
                        if (o === "*") {
                            if (e) {
                                return e + o + (s ? k : "");
                            }
                            return k;
                        }
                        return e ? t : `\\${t}`;
                    });
                    if (n === true) {
                        if (u.unescape === true) {
                            s = s.replace(/\\/g, "");
                        } else {
                            s = s.replace(/\\+/g, (t)=>t.length % 2 === 0 ? "\\\\" : t ? "\\" : "");
                        }
                    }
                    if (s === t && u.contains === true) {
                        m.output = t;
                        return m;
                    }
                    m.output = o.wrapOutput(s, m, e);
                    return m;
                }
                while(!eos()){
                    G = M();
                    if (G === "\0") {
                        continue;
                    }
                    if (G === "\\") {
                        const t = D();
                        if (t === "/" && u.bash !== true) {
                            continue;
                        }
                        if (t === "." || t === ";") {
                            continue;
                        }
                        if (!t) {
                            G += "\\";
                            push({
                                type: "text",
                                value: G
                            });
                            continue;
                        }
                        const e = /^\\+/.exec(remaining());
                        let n = 0;
                        if (e && e[0].length > 2) {
                            n = e[0].length;
                            m.index += n;
                            if (n % 2 !== 0) {
                                G += "\\";
                            }
                        }
                        if (u.unescape === true) {
                            G = M();
                        } else {
                            G += M();
                        }
                        if (m.brackets === 0) {
                            push({
                                type: "text",
                                value: G
                            });
                            continue;
                        }
                    }
                    if (m.brackets > 0 && (G !== "]" || B.value === "[" || B.value === "[^")) {
                        if (u.posix !== false && G === ":") {
                            const t = B.value.slice(1);
                            if (t.includes("[")) {
                                B.posix = true;
                                if (t.includes(":")) {
                                    const t = B.value.lastIndexOf("[");
                                    const e = B.value.slice(0, t);
                                    const u = B.value.slice(t + 2);
                                    const n = r[u];
                                    if (n) {
                                        B.value = e + n;
                                        m.backtrack = true;
                                        M();
                                        if (!f.output && A.indexOf(B) === 1) {
                                            f.output = C;
                                        }
                                        continue;
                                    }
                                }
                            }
                        }
                        if (G === "[" && D() !== ":" || G === "-" && D() === "]") {
                            G = `\\${G}`;
                        }
                        if (G === "]" && (B.value === "[" || B.value === "[^")) {
                            G = `\\${G}`;
                        }
                        if (u.posix === true && G === "!" && B.value === "[") {
                            G = "^";
                        }
                        B.value += G;
                        append({
                            value: G
                        });
                        continue;
                    }
                    if (m.quotes === 1 && G !== '"') {
                        G = o.escapeRegex(G);
                        B.value += G;
                        append({
                            value: G
                        });
                        continue;
                    }
                    if (G === '"') {
                        m.quotes = m.quotes === 1 ? 0 : 1;
                        if (u.keepQuotes === true) {
                            push({
                                type: "text",
                                value: G
                            });
                        }
                        continue;
                    }
                    if (G === "(") {
                        increment("parens");
                        push({
                            type: "paren",
                            value: G
                        });
                        continue;
                    }
                    if (G === ")") {
                        if (m.parens === 0 && u.strictBrackets === true) {
                            throw new SyntaxError(syntaxError("opening", "("));
                        }
                        const t = w[w.length - 1];
                        if (t && m.parens === t.parens + 1) {
                            extglobClose(w.pop());
                            continue;
                        }
                        push({
                            type: "paren",
                            value: G,
                            output: m.parens ? ")" : "\\)"
                        });
                        decrement("parens");
                        continue;
                    }
                    if (G === "[") {
                        if (u.nobracket === true || !remaining().includes("]")) {
                            if (u.nobracket !== true && u.strictBrackets === true) {
                                throw new SyntaxError(syntaxError("closing", "]"));
                            }
                            G = `\\${G}`;
                        } else {
                            increment("brackets");
                        }
                        push({
                            type: "bracket",
                            value: G
                        });
                        continue;
                    }
                    if (G === "]") {
                        if (u.nobracket === true || B && B.type === "bracket" && B.value.length === 1) {
                            push({
                                type: "text",
                                value: G,
                                output: `\\${G}`
                            });
                            continue;
                        }
                        if (m.brackets === 0) {
                            if (u.strictBrackets === true) {
                                throw new SyntaxError(syntaxError("opening", "["));
                            }
                            push({
                                type: "text",
                                value: G,
                                output: `\\${G}`
                            });
                            continue;
                        }
                        decrement("brackets");
                        const t = B.value.slice(1);
                        if (B.posix !== true && t[0] === "^" && !t.includes("/")) {
                            G = `/${G}`;
                        }
                        B.value += G;
                        append({
                            value: G
                        });
                        if (u.literalBrackets === false || o.hasRegexChars(t)) {
                            continue;
                        }
                        const e = o.escapeRegex(B.value);
                        m.output = m.output.slice(0, -B.value.length);
                        if (u.literalBrackets === true) {
                            m.output += e;
                            B.value = e;
                            continue;
                        }
                        B.value = `(${_}${e}|${B.value})`;
                        m.output += B.value;
                        continue;
                    }
                    if (G === "{" && u.nobrace !== true) {
                        increment("braces");
                        const t = {
                            type: "brace",
                            value: G,
                            output: "(",
                            outputIndex: m.output.length,
                            tokensIndex: m.tokens.length
                        };
                        N.push(t);
                        push(t);
                        continue;
                    }
                    if (G === "}") {
                        const t = N[N.length - 1];
                        if (u.nobrace === true || !t) {
                            push({
                                type: "text",
                                value: G,
                                output: G
                            });
                            continue;
                        }
                        let e = ")";
                        if (t.dots === true) {
                            const t = A.slice();
                            const n = [];
                            for(let e = t.length - 1; e >= 0; e--){
                                A.pop();
                                if (t[e].type === "brace") {
                                    break;
                                }
                                if (t[e].type !== "dots") {
                                    n.unshift(t[e].value);
                                }
                            }
                            e = expandRange(n, u);
                            m.backtrack = true;
                        }
                        if (t.comma !== true && t.dots !== true) {
                            const u = m.output.slice(0, t.outputIndex);
                            const n = m.tokens.slice(t.tokensIndex);
                            t.value = t.output = "\\{";
                            G = e = "\\}";
                            m.output = u;
                            for (const t of n){
                                m.output += t.output || t.value;
                            }
                        }
                        push({
                            type: "brace",
                            value: G,
                            output: e
                        });
                        decrement("braces");
                        N.pop();
                        continue;
                    }
                    if (G === "|") {
                        if (w.length > 0) {
                            w[w.length - 1].conditions++;
                        }
                        push({
                            type: "text",
                            value: G
                        });
                        continue;
                    }
                    if (G === ",") {
                        let t = G;
                        const e = N[N.length - 1];
                        if (e && I[I.length - 1] === "braces") {
                            e.comma = true;
                            t = "|";
                        }
                        push({
                            type: "comma",
                            value: G,
                            output: t
                        });
                        continue;
                    }
                    if (G === "/") {
                        if (B.type === "dot" && m.index === m.start + 1) {
                            m.start = m.index + 1;
                            m.consumed = "";
                            m.output = "";
                            A.pop();
                            B = f;
                            continue;
                        }
                        push({
                            type: "slash",
                            value: G,
                            output: b
                        });
                        continue;
                    }
                    if (G === ".") {
                        if (m.braces > 0 && B.type === "dot") {
                            if (B.value === ".") B.output = h;
                            const t = N[N.length - 1];
                            B.type = "dots";
                            B.output += G;
                            B.value += G;
                            t.dots = true;
                            continue;
                        }
                        if (m.braces + m.parens === 0 && B.type !== "bos" && B.type !== "slash") {
                            push({
                                type: "text",
                                value: G,
                                output: h
                            });
                            continue;
                        }
                        push({
                            type: "dot",
                            value: G,
                            output: h
                        });
                        continue;
                    }
                    if (G === "?") {
                        const t = B && B.value === "(";
                        if (!t && u.noextglob !== true && D() === "(" && D(2) !== "?") {
                            extglobOpen("qmark", G);
                            continue;
                        }
                        if (B && B.type === "paren") {
                            const t = D();
                            let e = G;
                            if (B.value === "(" && !/[!=<:]/.test(t) || t === "<" && !/<([!=]|\w+>)/.test(remaining())) {
                                e = `\\${G}`;
                            }
                            push({
                                type: "text",
                                value: G,
                                output: e
                            });
                            continue;
                        }
                        if (u.dot !== true && (B.type === "slash" || B.type === "bos")) {
                            push({
                                type: "qmark",
                                value: G,
                                output: v
                            });
                            continue;
                        }
                        push({
                            type: "qmark",
                            value: G,
                            output: H
                        });
                        continue;
                    }
                    if (G === "!") {
                        if (u.noextglob !== true && D() === "(") {
                            if (D(2) !== "?" || !/[!=<:]/.test(D(3))) {
                                extglobOpen("negate", G);
                                continue;
                            }
                        }
                        if (u.nonegate !== true && m.index === 0) {
                            negate();
                            continue;
                        }
                    }
                    if (G === "+") {
                        if (u.noextglob !== true && D() === "(" && D(2) !== "?") {
                            extglobOpen("plus", G);
                            continue;
                        }
                        if (B && B.value === "(" || u.regex === false) {
                            push({
                                type: "plus",
                                value: G,
                                output: g
                            });
                            continue;
                        }
                        if (B && (B.type === "bracket" || B.type === "paren" || B.type === "brace") || m.parens > 0) {
                            push({
                                type: "plus",
                                value: G
                            });
                            continue;
                        }
                        push({
                            type: "plus",
                            value: g
                        });
                        continue;
                    }
                    if (G === "@") {
                        if (u.noextglob !== true && D() === "(" && D(2) !== "?") {
                            push({
                                type: "at",
                                extglob: true,
                                value: G,
                                output: ""
                            });
                            continue;
                        }
                        push({
                            type: "text",
                            value: G
                        });
                        continue;
                    }
                    if (G !== "*") {
                        if (G === "$" || G === "^") {
                            G = `\\${G}`;
                        }
                        const t = a.exec(remaining());
                        if (t) {
                            G += t[0];
                            m.index += t[0].length;
                        }
                        push({
                            type: "text",
                            value: G
                        });
                        continue;
                    }
                    if (B && (B.type === "globstar" || B.star === true)) {
                        B.type = "star";
                        B.star = true;
                        B.value += G;
                        B.output = k;
                        m.backtrack = true;
                        m.globstar = true;
                        consume(G);
                        continue;
                    }
                    let e = remaining();
                    if (u.noextglob !== true && /^\([^?]/.test(e)) {
                        extglobOpen("star", G);
                        continue;
                    }
                    if (B.type === "star") {
                        if (u.noglobstar === true) {
                            consume(G);
                            continue;
                        }
                        const n = B.prev;
                        const o = n.prev;
                        const s = n.type === "slash" || n.type === "bos";
                        const r = o && (o.type === "star" || o.type === "globstar");
                        if (u.bash === true && (!s || e[0] && e[0] !== "/")) {
                            push({
                                type: "star",
                                value: G,
                                output: ""
                            });
                            continue;
                        }
                        const a = m.braces > 0 && (n.type === "comma" || n.type === "brace");
                        const i = w.length && (n.type === "pipe" || n.type === "paren");
                        if (!s && n.type !== "paren" && !a && !i) {
                            push({
                                type: "star",
                                value: G,
                                output: ""
                            });
                            continue;
                        }
                        while(e.slice(0, 3) === "/**"){
                            const u = t[m.index + 4];
                            if (u && u !== "/") {
                                break;
                            }
                            e = e.slice(3);
                            consume("/**", 3);
                        }
                        if (n.type === "bos" && eos()) {
                            B.type = "globstar";
                            B.value += G;
                            B.output = globstar(u);
                            m.output = B.output;
                            m.globstar = true;
                            consume(G);
                            continue;
                        }
                        if (n.type === "slash" && n.prev.type !== "bos" && !r && eos()) {
                            m.output = m.output.slice(0, -(n.output + B.output).length);
                            n.output = `(?:${n.output}`;
                            B.type = "globstar";
                            B.output = globstar(u) + (u.strictSlashes ? ")" : "|$)");
                            B.value += G;
                            m.globstar = true;
                            m.output += n.output + B.output;
                            consume(G);
                            continue;
                        }
                        if (n.type === "slash" && n.prev.type !== "bos" && e[0] === "/") {
                            const t = e[1] !== void 0 ? "|$" : "";
                            m.output = m.output.slice(0, -(n.output + B.output).length);
                            n.output = `(?:${n.output}`;
                            B.type = "globstar";
                            B.output = `${globstar(u)}${b}|${b}${t})`;
                            B.value += G;
                            m.output += n.output + B.output;
                            m.globstar = true;
                            consume(G + M());
                            push({
                                type: "slash",
                                value: "/",
                                output: ""
                            });
                            continue;
                        }
                        if (n.type === "bos" && e[0] === "/") {
                            B.type = "globstar";
                            B.value += G;
                            B.output = `(?:^|${b}|${globstar(u)}${b})`;
                            m.output = B.output;
                            m.globstar = true;
                            consume(G + M());
                            push({
                                type: "slash",
                                value: "/",
                                output: ""
                            });
                            continue;
                        }
                        m.output = m.output.slice(0, -B.output.length);
                        B.type = "globstar";
                        B.output = globstar(u);
                        B.value += G;
                        m.output += B.output;
                        m.globstar = true;
                        consume(G);
                        continue;
                    }
                    const n = {
                        type: "star",
                        value: G,
                        output: k
                    };
                    if (u.bash === true) {
                        n.output = ".*?";
                        if (B.type === "bos" || B.type === "slash") {
                            n.output = T + n.output;
                        }
                        push(n);
                        continue;
                    }
                    if (B && (B.type === "bracket" || B.type === "paren") && u.regex === true) {
                        n.output = G;
                        push(n);
                        continue;
                    }
                    if (m.index === m.start || B.type === "slash" || B.type === "dot") {
                        if (B.type === "dot") {
                            m.output += x;
                            B.output += x;
                        } else if (u.dot === true) {
                            m.output += S;
                            B.output += S;
                        } else {
                            m.output += T;
                            B.output += T;
                        }
                        if (D() !== "*") {
                            m.output += C;
                            B.output += C;
                        }
                    }
                    push(n);
                }
                while(m.brackets > 0){
                    if (u.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
                    m.output = o.escapeLast(m.output, "[");
                    decrement("brackets");
                }
                while(m.parens > 0){
                    if (u.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
                    m.output = o.escapeLast(m.output, "(");
                    decrement("parens");
                }
                while(m.braces > 0){
                    if (u.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
                    m.output = o.escapeLast(m.output, "{");
                    decrement("braces");
                }
                if (u.strictSlashes !== true && (B.type === "star" || B.type === "bracket")) {
                    push({
                        type: "maybe_slash",
                        value: "",
                        output: `${b}?`
                    });
                }
                if (m.backtrack === true) {
                    m.output = "";
                    for (const t of m.tokens){
                        m.output += t.output != null ? t.output : t.value;
                        if (t.suffix) {
                            m.output += t.suffix;
                        }
                    }
                }
                return m;
            };
            parse.fastpaths = (t, e)=>{
                const u = {
                    ...e
                };
                const r = typeof u.maxLength === "number" ? Math.min(s, u.maxLength) : s;
                const a = t.length;
                if (a > r) {
                    throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`);
                }
                t = c[t] || t;
                const { DOT_LITERAL: i, SLASH_LITERAL: p, ONE_CHAR: l, DOTS_SLASH: f, NO_DOT: A, NO_DOTS: _, NO_DOTS_SLASH: R, STAR: E, START_ANCHOR: h } = n.globChars(u.windows);
                const g = u.dot ? _ : A;
                const b = u.dot ? R : A;
                const C = u.capture ? "" : "?:";
                const y = {
                    negated: false,
                    prefix: ""
                };
                let $ = u.bash === true ? ".*?" : E;
                if (u.capture) {
                    $ = `(${$})`;
                }
                const globstar = (t)=>{
                    if (t.noglobstar === true) return $;
                    return `(${C}(?:(?!${h}${t.dot ? f : i}).)*?)`;
                };
                const create = (t)=>{
                    switch(t){
                        case "*":
                            return `${g}${l}${$}`;
                        case ".*":
                            return `${i}${l}${$}`;
                        case "*.*":
                            return `${g}${$}${i}${l}${$}`;
                        case "*/*":
                            return `${g}${$}${p}${l}${b}${$}`;
                        case "**":
                            return g + globstar(u);
                        case "**/*":
                            return `(?:${g}${globstar(u)}${p})?${b}${l}${$}`;
                        case "**/*.*":
                            return `(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;
                        case "**/.*":
                            return `(?:${g}${globstar(u)}${p})?${i}${l}${$}`;
                        default:
                            {
                                const e = /^(.*?)\.(\w+)$/.exec(t);
                                if (!e) return;
                                const u = create(e[1]);
                                if (!u) return;
                                return u + i + e[2];
                            }
                    }
                };
                const x = o.removePrefix(t, y);
                let S = create(x);
                if (S && u.strictSlashes !== true) {
                    S += `${p}?`;
                }
                return S;
            };
            t.exports = parse;
        },
        510: (t, e, u)=>{
            const n = u(716);
            const o = u(697);
            const s = u(96);
            const r = u(154);
            const isObject = (t)=>t && typeof t === "object" && !Array.isArray(t);
            const picomatch = (t, e, u = false)=>{
                if (Array.isArray(t)) {
                    const n = t.map((t)=>picomatch(t, e, u));
                    const arrayMatcher = (t)=>{
                        for (const e of n){
                            const u = e(t);
                            if (u) return u;
                        }
                        return false;
                    };
                    return arrayMatcher;
                }
                const n = isObject(t) && t.tokens && t.input;
                if (t === "" || typeof t !== "string" && !n) {
                    throw new TypeError("Expected pattern to be a non-empty string");
                }
                const o = e || {};
                const s = o.windows;
                const r = n ? picomatch.compileRe(t, e) : picomatch.makeRe(t, e, false, true);
                const a = r.state;
                delete r.state;
                let isIgnored = ()=>false;
                if (o.ignore) {
                    const t = {
                        ...e,
                        ignore: null,
                        onMatch: null,
                        onResult: null
                    };
                    isIgnored = picomatch(o.ignore, t, u);
                }
                const matcher = (u, n = false)=>{
                    const { isMatch: i, match: c, output: p } = picomatch.test(u, r, e, {
                        glob: t,
                        posix: s
                    });
                    const l = {
                        glob: t,
                        state: a,
                        regex: r,
                        posix: s,
                        input: u,
                        output: p,
                        match: c,
                        isMatch: i
                    };
                    if (typeof o.onResult === "function") {
                        o.onResult(l);
                    }
                    if (i === false) {
                        l.isMatch = false;
                        return n ? l : false;
                    }
                    if (isIgnored(u)) {
                        if (typeof o.onIgnore === "function") {
                            o.onIgnore(l);
                        }
                        l.isMatch = false;
                        return n ? l : false;
                    }
                    if (typeof o.onMatch === "function") {
                        o.onMatch(l);
                    }
                    return n ? l : true;
                };
                if (u) {
                    matcher.state = a;
                }
                return matcher;
            };
            picomatch.test = (t, e, u, { glob: n, posix: o } = {})=>{
                if (typeof t !== "string") {
                    throw new TypeError("Expected input to be a string");
                }
                if (t === "") {
                    return {
                        isMatch: false,
                        output: ""
                    };
                }
                const r = u || {};
                const a = r.format || (o ? s.toPosixSlashes : null);
                let i = t === n;
                let c = i && a ? a(t) : t;
                if (i === false) {
                    c = a ? a(t) : t;
                    i = c === n;
                }
                if (i === false || r.capture === true) {
                    if (r.matchBase === true || r.basename === true) {
                        i = picomatch.matchBase(t, e, u, o);
                    } else {
                        i = e.exec(c);
                    }
                }
                return {
                    isMatch: Boolean(i),
                    match: i,
                    output: c
                };
            };
            picomatch.matchBase = (t, e, u)=>{
                const n = e instanceof RegExp ? e : picomatch.makeRe(e, u);
                return n.test(s.basename(t));
            };
            picomatch.isMatch = (t, e, u)=>picomatch(e, u)(t);
            picomatch.parse = (t, e)=>{
                if (Array.isArray(t)) return t.map((t)=>picomatch.parse(t, e));
                return o(t, {
                    ...e,
                    fastpaths: false
                });
            };
            picomatch.scan = (t, e)=>n(t, e);
            picomatch.compileRe = (t, e, u = false, n = false)=>{
                if (u === true) {
                    return t.output;
                }
                const o = e || {};
                const s = o.contains ? "" : "^";
                const r = o.contains ? "" : "$";
                let a = `${s}(?:${t.output})${r}`;
                if (t && t.negated === true) {
                    a = `^(?!${a}).*$`;
                }
                const i = picomatch.toRegex(a, e);
                if (n === true) {
                    i.state = t;
                }
                return i;
            };
            picomatch.makeRe = (t, e = {}, u = false, n = false)=>{
                if (!t || typeof t !== "string") {
                    throw new TypeError("Expected a non-empty string");
                }
                let s = {
                    negated: false,
                    fastpaths: true
                };
                if (e.fastpaths !== false && (t[0] === "." || t[0] === "*")) {
                    s.output = o.fastpaths(t, e);
                }
                if (!s.output) {
                    s = o(t, e);
                }
                return picomatch.compileRe(s, e, u, n);
            };
            picomatch.toRegex = (t, e)=>{
                try {
                    const u = e || {};
                    return new RegExp(t, u.flags || (u.nocase ? "i" : ""));
                } catch (t) {
                    if (e && e.debug === true) throw t;
                    return /$^/;
                }
            };
            picomatch.constants = r;
            t.exports = picomatch;
        },
        716: (t, e, u)=>{
            const n = u(96);
            const { CHAR_ASTERISK: o, CHAR_AT: s, CHAR_BACKWARD_SLASH: r, CHAR_COMMA: a, CHAR_DOT: i, CHAR_EXCLAMATION_MARK: c, CHAR_FORWARD_SLASH: p, CHAR_LEFT_CURLY_BRACE: l, CHAR_LEFT_PARENTHESES: f, CHAR_LEFT_SQUARE_BRACKET: A, CHAR_PLUS: _, CHAR_QUESTION_MARK: R, CHAR_RIGHT_CURLY_BRACE: E, CHAR_RIGHT_PARENTHESES: h, CHAR_RIGHT_SQUARE_BRACKET: g } = u(154);
            const isPathSeparator = (t)=>t === p || t === r;
            const depth = (t)=>{
                if (t.isPrefix !== true) {
                    t.depth = t.isGlobstar ? Infinity : 1;
                }
            };
            const scan = (t, e)=>{
                const u = e || {};
                const b = t.length - 1;
                const C = u.parts === true || u.scanToEnd === true;
                const y = [];
                const $ = [];
                const x = [];
                let S = t;
                let H = -1;
                let v = 0;
                let d = 0;
                let L = false;
                let T = false;
                let O = false;
                let k = false;
                let m = false;
                let w = false;
                let N = false;
                let I = false;
                let B = false;
                let G = false;
                let D = 0;
                let M;
                let P;
                let K = {
                    value: "",
                    depth: 0,
                    isGlob: false
                };
                const eos = ()=>H >= b;
                const peek = ()=>S.charCodeAt(H + 1);
                const advance = ()=>{
                    M = P;
                    return S.charCodeAt(++H);
                };
                while(H < b){
                    P = advance();
                    let t;
                    if (P === r) {
                        N = K.backslashes = true;
                        P = advance();
                        if (P === l) {
                            w = true;
                        }
                        continue;
                    }
                    if (w === true || P === l) {
                        D++;
                        while(eos() !== true && (P = advance())){
                            if (P === r) {
                                N = K.backslashes = true;
                                advance();
                                continue;
                            }
                            if (P === l) {
                                D++;
                                continue;
                            }
                            if (w !== true && P === i && (P = advance()) === i) {
                                L = K.isBrace = true;
                                O = K.isGlob = true;
                                G = true;
                                if (C === true) {
                                    continue;
                                }
                                break;
                            }
                            if (w !== true && P === a) {
                                L = K.isBrace = true;
                                O = K.isGlob = true;
                                G = true;
                                if (C === true) {
                                    continue;
                                }
                                break;
                            }
                            if (P === E) {
                                D--;
                                if (D === 0) {
                                    w = false;
                                    L = K.isBrace = true;
                                    G = true;
                                    break;
                                }
                            }
                        }
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (P === p) {
                        y.push(H);
                        $.push(K);
                        K = {
                            value: "",
                            depth: 0,
                            isGlob: false
                        };
                        if (G === true) continue;
                        if (M === i && H === v + 1) {
                            v += 2;
                            continue;
                        }
                        d = H + 1;
                        continue;
                    }
                    if (u.noext !== true) {
                        const t = P === _ || P === s || P === o || P === R || P === c;
                        if (t === true && peek() === f) {
                            O = K.isGlob = true;
                            k = K.isExtglob = true;
                            G = true;
                            if (P === c && H === v) {
                                B = true;
                            }
                            if (C === true) {
                                while(eos() !== true && (P = advance())){
                                    if (P === r) {
                                        N = K.backslashes = true;
                                        P = advance();
                                        continue;
                                    }
                                    if (P === h) {
                                        O = K.isGlob = true;
                                        G = true;
                                        break;
                                    }
                                }
                                continue;
                            }
                            break;
                        }
                    }
                    if (P === o) {
                        if (M === o) m = K.isGlobstar = true;
                        O = K.isGlob = true;
                        G = true;
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (P === R) {
                        O = K.isGlob = true;
                        G = true;
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (P === A) {
                        while(eos() !== true && (t = advance())){
                            if (t === r) {
                                N = K.backslashes = true;
                                advance();
                                continue;
                            }
                            if (t === g) {
                                T = K.isBracket = true;
                                O = K.isGlob = true;
                                G = true;
                                break;
                            }
                        }
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                    if (u.nonegate !== true && P === c && H === v) {
                        I = K.negated = true;
                        v++;
                        continue;
                    }
                    if (u.noparen !== true && P === f) {
                        O = K.isGlob = true;
                        if (C === true) {
                            while(eos() !== true && (P = advance())){
                                if (P === f) {
                                    N = K.backslashes = true;
                                    P = advance();
                                    continue;
                                }
                                if (P === h) {
                                    G = true;
                                    break;
                                }
                            }
                            continue;
                        }
                        break;
                    }
                    if (O === true) {
                        G = true;
                        if (C === true) {
                            continue;
                        }
                        break;
                    }
                }
                if (u.noext === true) {
                    k = false;
                    O = false;
                }
                let U = S;
                let X = "";
                let F = "";
                if (v > 0) {
                    X = S.slice(0, v);
                    S = S.slice(v);
                    d -= v;
                }
                if (U && O === true && d > 0) {
                    U = S.slice(0, d);
                    F = S.slice(d);
                } else if (O === true) {
                    U = "";
                    F = S;
                } else {
                    U = S;
                }
                if (U && U !== "" && U !== "/" && U !== S) {
                    if (isPathSeparator(U.charCodeAt(U.length - 1))) {
                        U = U.slice(0, -1);
                    }
                }
                if (u.unescape === true) {
                    if (F) F = n.removeBackslashes(F);
                    if (U && N === true) {
                        U = n.removeBackslashes(U);
                    }
                }
                const Q = {
                    prefix: X,
                    input: t,
                    start: v,
                    base: U,
                    glob: F,
                    isBrace: L,
                    isBracket: T,
                    isGlob: O,
                    isExtglob: k,
                    isGlobstar: m,
                    negated: I,
                    negatedExtglob: B
                };
                if (u.tokens === true) {
                    Q.maxDepth = 0;
                    if (!isPathSeparator(P)) {
                        $.push(K);
                    }
                    Q.tokens = $;
                }
                if (u.parts === true || u.tokens === true) {
                    let e;
                    for(let n = 0; n < y.length; n++){
                        const o = e ? e + 1 : v;
                        const s = y[n];
                        const r = t.slice(o, s);
                        if (u.tokens) {
                            if (n === 0 && v !== 0) {
                                $[n].isPrefix = true;
                                $[n].value = X;
                            } else {
                                $[n].value = r;
                            }
                            depth($[n]);
                            Q.maxDepth += $[n].depth;
                        }
                        if (n !== 0 || r !== "") {
                            x.push(r);
                        }
                        e = s;
                    }
                    if (e && e + 1 < t.length) {
                        const n = t.slice(e + 1);
                        x.push(n);
                        if (u.tokens) {
                            $[$.length - 1].value = n;
                            depth($[$.length - 1]);
                            Q.maxDepth += $[$.length - 1].depth;
                        }
                    }
                    Q.slashes = y;
                    Q.parts = x;
                }
                return Q;
            };
            t.exports = scan;
        },
        96: (t, e, u)=>{
            const { REGEX_BACKSLASH: n, REGEX_REMOVE_BACKSLASH: o, REGEX_SPECIAL_CHARS: s, REGEX_SPECIAL_CHARS_GLOBAL: r } = u(154);
            e.isObject = (t)=>t !== null && typeof t === "object" && !Array.isArray(t);
            e.hasRegexChars = (t)=>s.test(t);
            e.isRegexChar = (t)=>t.length === 1 && e.hasRegexChars(t);
            e.escapeRegex = (t)=>t.replace(r, "\\$1");
            e.toPosixSlashes = (t)=>t.replace(n, "/");
            e.removeBackslashes = (t)=>t.replace(o, (t)=>t === "\\" ? "" : t);
            e.escapeLast = (t, u, n)=>{
                const o = t.lastIndexOf(u, n);
                if (o === -1) return t;
                if (t[o - 1] === "\\") return e.escapeLast(t, u, o - 1);
                return `${t.slice(0, o)}\\${t.slice(o)}`;
            };
            e.removePrefix = (t, e = {})=>{
                let u = t;
                if (u.startsWith("./")) {
                    u = u.slice(2);
                    e.prefix = "./";
                }
                return u;
            };
            e.wrapOutput = (t, e = {}, u = {})=>{
                const n = u.contains ? "" : "^";
                const o = u.contains ? "" : "$";
                let s = `${n}(?:${t})${o}`;
                if (e.negated === true) {
                    s = `(?:^(?!${s}).*$)`;
                }
                return s;
            };
            e.basename = (t, { windows: e } = {})=>{
                const u = t.split(e ? /[\\/]/ : "/");
                const n = u[u.length - 1];
                if (n === "") {
                    return u[u.length - 2];
                }
                return n;
            };
        }
    };
    var e = {};
    function __nccwpck_require__(u) {
        var n = e[u];
        if (n !== undefined) {
            return n.exports;
        }
        var o = e[u] = {
            exports: {}
        };
        var s = true;
        try {
            t[u](o, o.exports, __nccwpck_require__);
            s = false;
        } finally{
            if (s) delete e[u];
        }
        return o.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/picomatch") + "/";
    var u = __nccwpck_require__(170);
    module.exports = u;
})();
}),
"[project]/node_modules/next/dist/shared/lib/match-local-pattern.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    hasLocalMatch: null,
    matchLocalPattern: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    hasLocalMatch: function() {
        return hasLocalMatch;
    },
    matchLocalPattern: function() {
        return matchLocalPattern;
    }
});
const _picomatch = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/picomatch/index.js [app-client] (ecmascript)");
function matchLocalPattern(pattern, url) {
    if (pattern.search !== undefined) {
        if (pattern.search !== url.search) {
            return false;
        }
    }
    if (!(0, _picomatch.makeRe)(pattern.pathname ?? '**', {
        dot: true
    }).test(url.pathname)) {
        return false;
    }
    return true;
}
function hasLocalMatch(localPatterns, urlPathAndQuery) {
    if (!localPatterns) {
        // if the user didn't define "localPatterns", we allow all local images
        return true;
    }
    const url = new URL(urlPathAndQuery, 'http://n');
    return localPatterns.some((p)=>matchLocalPattern(p, url));
} //# sourceMappingURL=match-local-pattern.js.map
}),
"[project]/node_modules/next/dist/shared/lib/match-remote-pattern.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    hasRemoteMatch: null,
    matchRemotePattern: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    hasRemoteMatch: function() {
        return hasRemoteMatch;
    },
    matchRemotePattern: function() {
        return matchRemotePattern;
    }
});
const _picomatch = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/picomatch/index.js [app-client] (ecmascript)");
function matchRemotePattern(pattern, url) {
    if (pattern.protocol !== undefined) {
        if (pattern.protocol.replace(/:$/, '') !== url.protocol.replace(/:$/, '')) {
            return false;
        }
    }
    if (pattern.port !== undefined) {
        if (pattern.port !== url.port) {
            return false;
        }
    }
    if (pattern.hostname === undefined) {
        throw Object.defineProperty(new Error(`Pattern should define hostname but found\n${JSON.stringify(pattern)}`), "__NEXT_ERROR_CODE", {
            value: "E410",
            enumerable: false,
            configurable: true
        });
    } else {
        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {
            return false;
        }
    }
    if (pattern.search !== undefined) {
        if (pattern.search !== url.search) {
            return false;
        }
    }
    // Should be the same as writeImagesManifest()
    if (!(0, _picomatch.makeRe)(pattern.pathname ?? '**', {
        dot: true
    }).test(url.pathname)) {
        return false;
    }
    return true;
}
function hasRemoteMatch(domains, remotePatterns, url) {
    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));
} //# sourceMappingURL=match-remote-pattern.js.map
}),
"[project]/node_modules/next/dist/shared/lib/image-loader.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _findclosestquality = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/find-closest-quality.js [app-client] (ecmascript)");
function defaultLoader({ config, src, width, quality }) {
    if (src.startsWith('/') && src.includes('?') && config.localPatterns?.length === 1 && config.localPatterns[0].pathname === '**' && config.localPatterns[0].search === '') {
        throw Object.defineProperty(new Error(`Image with src "${src}" is using a query string which is not configured in images.localPatterns.` + `\nRead more: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns`), "__NEXT_ERROR_CODE", {
            value: "E871",
            enumerable: false,
            configurable: true
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        const missingValues = [];
        // these should always be provided but make sure they are
        if (!src) missingValues.push('src');
        if (!width) missingValues.push('width');
        if (missingValues.length > 0) {
            throw Object.defineProperty(new Error(`Next Image Optimization requires ${missingValues.join(', ')} to be provided. Make sure you pass them as props to the \`next/image\` component. Received: ${JSON.stringify({
                src,
                width,
                quality
            })}`), "__NEXT_ERROR_CODE", {
                value: "E188",
                enumerable: false,
                configurable: true
            });
        }
        if (src.startsWith('//')) {
            throw Object.defineProperty(new Error(`Failed to parse src "${src}" on \`next/image\`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)`), "__NEXT_ERROR_CODE", {
                value: "E360",
                enumerable: false,
                configurable: true
            });
        }
        if (src.startsWith('/') && config.localPatterns) {
            if ("TURBOPACK compile-time truthy", 1) {
                // We use dynamic require because this should only error in development
                const { hasLocalMatch } = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/match-local-pattern.js [app-client] (ecmascript)");
                if (!hasLocalMatch(config.localPatterns, src)) {
                    throw Object.defineProperty(new Error(`Invalid src prop (${src}) on \`next/image\` does not match \`images.localPatterns\` configured in your \`next.config.js\`\n` + `See more info: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns`), "__NEXT_ERROR_CODE", {
                        value: "E426",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
        if (!src.startsWith('/') && (config.domains || config.remotePatterns)) {
            let parsedSrc;
            try {
                parsedSrc = new URL(src);
            } catch (err) {
                console.error(err);
                throw Object.defineProperty(new Error(`Failed to parse src "${src}" on \`next/image\`, if using relative image it must start with a leading slash "/" or be an absolute URL (http:// or https://)`), "__NEXT_ERROR_CODE", {
                    value: "E63",
                    enumerable: false,
                    configurable: true
                });
            }
            if ("TURBOPACK compile-time truthy", 1) {
                // We use dynamic require because this should only error in development
                const { hasRemoteMatch } = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/match-remote-pattern.js [app-client] (ecmascript)");
                if (!hasRemoteMatch(config.domains, config.remotePatterns, parsedSrc)) {
                    throw Object.defineProperty(new Error(`Invalid src prop (${src}) on \`next/image\`, hostname "${parsedSrc.hostname}" is not configured under images in your \`next.config.js\`\n` + `See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host`), "__NEXT_ERROR_CODE", {
                        value: "E231",
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
    }
    const q = (0, _findclosestquality.findClosestQuality)(quality, config);
    return `${config.path}?url=${encodeURIComponent(src)}&w=${width}&q=${q}${src.startsWith('/_next/static/media/') && ("TURBOPACK compile-time value", false) ? "TURBOPACK unreachable" : ''}`;
}
// We use this to determine if the import is the default loader
// or a custom loader defined by the user in next.config.js
defaultLoader.__next_img_default = true;
const _default = defaultLoader; //# sourceMappingURL=image-loader.js.map
}),
"[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useMergedRef", {
    enumerable: true,
    get: function() {
        return useMergedRef;
    }
});
const _react = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
function useMergedRef(refA, refB) {
    const cleanupA = (0, _react.useRef)(null);
    const cleanupB = (0, _react.useRef)(null);
    // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.
    // (this happens often if the user doesn't pass a ref to Link/Form/Image)
    // But this can cause us to leak a cleanup-ref into user code (previously via `<Link legacyBehavior>`),
    // and the user might pass that ref into ref-merging library that doesn't support cleanup refs
    // (because it hasn't been updated for React 19)
    // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.
    // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.
    return (0, _react.useCallback)((current)=>{
        if (current === null) {
            const cleanupFnA = cleanupA.current;
            if (cleanupFnA) {
                cleanupA.current = null;
                cleanupFnA();
            }
            const cleanupFnB = cleanupB.current;
            if (cleanupFnB) {
                cleanupB.current = null;
                cleanupFnB();
            }
        } else {
            if (refA) {
                cleanupA.current = applyRef(refA, current);
            }
            if (refB) {
                cleanupB.current = applyRef(refB, current);
            }
        }
    }, [
        refA,
        refB
    ]);
}
function applyRef(refA, current) {
    if (typeof refA === 'function') {
        const cleanup = refA(current);
        if (typeof cleanup === 'function') {
            return cleanup;
        } else {
            return ()=>refA(null);
        }
    } else {
        refA.current = current;
        return ()=>{
            refA.current = null;
        };
    }
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=use-merged-ref.js.map
}),
"[project]/node_modules/next/dist/client/image-component.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Image", {
    enumerable: true,
    get: function() {
        return Image;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _interop_require_wildcard = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_wildcard._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _reactdom = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)"));
const _head = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/head.js [app-client] (ecmascript)"));
const _getimgprops = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-img-props.js [app-client] (ecmascript)");
const _imageconfig = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-config.js [app-client] (ecmascript)");
const _imageconfigcontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js [app-client] (ecmascript)");
const _warnonce = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)");
const _routercontextsharedruntime = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/router-context.shared-runtime.js [app-client] (ecmascript)");
const _imageloader = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-loader.js [app-client] (ecmascript)"));
const _usemergedref = __turbopack_context__.r("[project]/node_modules/next/dist/client/use-merged-ref.js [app-client] (ecmascript)");
// This is replaced by webpack define plugin
const configEnv = ("TURBOPACK compile-time value", {
    "deviceSizes": ("TURBOPACK compile-time value", [
        ("TURBOPACK compile-time value", 640),
        ("TURBOPACK compile-time value", 750),
        ("TURBOPACK compile-time value", 828),
        ("TURBOPACK compile-time value", 1080),
        ("TURBOPACK compile-time value", 1200),
        ("TURBOPACK compile-time value", 1920),
        ("TURBOPACK compile-time value", 2048),
        ("TURBOPACK compile-time value", 3840)
    ]),
    "imageSizes": ("TURBOPACK compile-time value", [
        ("TURBOPACK compile-time value", 32),
        ("TURBOPACK compile-time value", 48),
        ("TURBOPACK compile-time value", 64),
        ("TURBOPACK compile-time value", 96),
        ("TURBOPACK compile-time value", 128),
        ("TURBOPACK compile-time value", 256),
        ("TURBOPACK compile-time value", 384)
    ]),
    "qualities": ("TURBOPACK compile-time value", [
        ("TURBOPACK compile-time value", 75)
    ]),
    "path": ("TURBOPACK compile-time value", "/_next/image"),
    "loader": ("TURBOPACK compile-time value", "default"),
    "dangerouslyAllowSVG": ("TURBOPACK compile-time value", false),
    "unoptimized": ("TURBOPACK compile-time value", true),
    "domains": ("TURBOPACK compile-time value", []),
    "remotePatterns": ("TURBOPACK compile-time value", []),
    "localPatterns": ("TURBOPACK compile-time value", [
        ("TURBOPACK compile-time value", {
            "pathname": ("TURBOPACK compile-time value", "**"),
            "search": ("TURBOPACK compile-time value", "")
        })
    ]),
    "output": ("TURBOPACK compile-time value", "export")
});
if (typeof window === 'undefined') {
    ;
    globalThis.__NEXT_IMAGE_IMPORTED = true;
}
// See https://stackoverflow.com/q/39777833/266535 for why we use this ref
// handler instead of the img's onLoad attribute.
function handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {
    const src = img?.src;
    if (!img || img['data-loaded-src'] === src) {
        return;
    }
    img['data-loaded-src'] = src;
    const p = 'decode' in img ? img.decode() : Promise.resolve();
    p.catch(()=>{}).then(()=>{
        if (!img.parentElement || !img.isConnected) {
            // Exit early in case of race condition:
            // - onload() is called
            // - decode() is called but incomplete
            // - unmount is called
            // - decode() completes
            return;
        }
        if (placeholder !== 'empty') {
            setBlurComplete(true);
        }
        if (onLoadRef?.current) {
            // Since we don't have the SyntheticEvent here,
            // we must create one with the same shape.
            // See https://reactjs.org/docs/events.html
            const event = new Event('load');
            Object.defineProperty(event, 'target', {
                writable: false,
                value: img
            });
            let prevented = false;
            let stopped = false;
            onLoadRef.current({
                ...event,
                nativeEvent: event,
                currentTarget: img,
                target: img,
                isDefaultPrevented: ()=>prevented,
                isPropagationStopped: ()=>stopped,
                persist: ()=>{},
                preventDefault: ()=>{
                    prevented = true;
                    event.preventDefault();
                },
                stopPropagation: ()=>{
                    stopped = true;
                    event.stopPropagation();
                }
            });
        }
        if (onLoadingCompleteRef?.current) {
            onLoadingCompleteRef.current(img);
        }
        if ("TURBOPACK compile-time truthy", 1) {
            const origSrc = new URL(src, 'http://n').searchParams.get('url') || src;
            if (img.getAttribute('data-nimg') === 'fill') {
                if (!unoptimized && (!sizesInput || sizesInput === '100vw')) {
                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;
                    if (widthViewportRatio < 0.6) {
                        if (sizesInput === '100vw') {
                            (0, _warnonce.warnOnce)(`Image with src "${origSrc}" has "fill" prop and "sizes" prop of "100vw", but image is not rendered at full viewport width. Please adjust "sizes" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes`);
                        } else {
                            (0, _warnonce.warnOnce)(`Image with src "${origSrc}" has "fill" but is missing "sizes" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes`);
                        }
                    }
                }
                if (img.parentElement) {
                    const { position } = window.getComputedStyle(img.parentElement);
                    const valid = [
                        'absolute',
                        'fixed',
                        'relative'
                    ];
                    if (!valid.includes(position)) {
                        (0, _warnonce.warnOnce)(`Image with src "${origSrc}" has "fill" and parent element with invalid "position". Provided "${position}" should be one of ${valid.map(String).join(',')}.`);
                    }
                }
                if (img.height === 0) {
                    (0, _warnonce.warnOnce)(`Image with src "${origSrc}" has "fill" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.`);
                }
            }
            const heightModified = img.height.toString() !== img.getAttribute('height');
            const widthModified = img.width.toString() !== img.getAttribute('width');
            if (heightModified && !widthModified || !heightModified && widthModified) {
                (0, _warnonce.warnOnce)(`Image with src "${origSrc}" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles 'width: "auto"' or 'height: "auto"' to maintain the aspect ratio.`);
            }
        }
    });
}
function getDynamicProps(fetchPriority) {
    if (Boolean(_react.use)) {
        // In React 19.0.0 or newer, we must use camelCase
        // prop to avoid "Warning: Invalid DOM property".
        // See https://github.com/facebook/react/pull/25927
        return {
            fetchPriority
        };
    }
    // In React 18.2.0 or older, we must use lowercase prop
    // to avoid "Warning: Invalid DOM property".
    return {
        fetchpriority: fetchPriority
    };
}
const ImageElement = /*#__PURE__*/ (0, _react.forwardRef)(({ src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, sizesInput, onLoad, onError, ...rest }, forwardedRef)=>{
    const ownRef = (0, _react.useCallback)((img)=>{
        if (!img) {
            return;
        }
        if (onError) {
            // If the image has an error before react hydrates, then the error is lost.
            // The workaround is to wait until the image is mounted which is after hydration,
            // then we set the src again to trigger the error handler (if there was an error).
            // eslint-disable-next-line no-self-assign
            img.src = img.src;
        }
        if ("TURBOPACK compile-time truthy", 1) {
            if (!src) {
                console.error(`Image is missing required "src" property:`, img);
            }
            if (img.getAttribute('alt') === null) {
                console.error(`Image is missing required "alt" property. Please add Alternative Text to describe the image for screen readers and search engines.`);
            }
        }
        if (img.complete) {
            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);
        }
    }, [
        src,
        placeholder,
        onLoadRef,
        onLoadingCompleteRef,
        setBlurComplete,
        onError,
        unoptimized,
        sizesInput
    ]);
    const ref = (0, _usemergedref.useMergedRef)(forwardedRef, ownRef);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("img", {
        ...rest,
        ...getDynamicProps(fetchPriority),
        // It's intended to keep `loading` before `src` because React updates
        // props in order which causes Safari/Firefox to not lazy load properly.
        // See https://github.com/facebook/react/issues/25883
        loading: loading,
        width: width,
        height: height,
        decoding: decoding,
        "data-nimg": fill ? 'fill' : '1',
        className: className,
        style: style,
        // It's intended to keep `src` the last attribute because React updates
        // attributes in order. If we keep `src` the first one, Safari will
        // immediately start to fetch `src`, before `sizes` and `srcSet` are even
        // updated by React. That causes multiple unnecessary requests if `srcSet`
        // and `sizes` are defined.
        // This bug cannot be reproduced in Chrome or Firefox.
        sizes: sizes,
        srcSet: srcSet,
        src: src,
        ref: ref,
        onLoad: (event)=>{
            const img = event.currentTarget;
            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);
        },
        onError: (event)=>{
            // if the real image fails to load, this will ensure "alt" is visible
            setShowAltText(true);
            if (placeholder !== 'empty') {
                // If the real image fails to load, this will still remove the placeholder.
                setBlurComplete(true);
            }
            if (onError) {
                onError(event);
            }
        }
    });
});
function ImagePreload({ isAppRouter, imgAttributes }) {
    const opts = {
        as: 'image',
        imageSrcSet: imgAttributes.srcSet,
        imageSizes: imgAttributes.sizes,
        crossOrigin: imgAttributes.crossOrigin,
        referrerPolicy: imgAttributes.referrerPolicy,
        ...getDynamicProps(imgAttributes.fetchPriority)
    };
    if (isAppRouter && _reactdom.default.preload) {
        _reactdom.default.preload(imgAttributes.src, opts);
        return null;
    }
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)("link", {
            rel: "preload",
            // Note how we omit the `href` attribute, as it would only be relevant
            // for browsers that do not support `imagesrcset`, and in those cases
            // it would cause the incorrect image to be preloaded.
            //
            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset
            href: imgAttributes.srcSet ? undefined : imgAttributes.src,
            ...opts
        }, '__nimg-' + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)
    });
}
const Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{
    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);
    // We're in the app directory if there is no pages router.
    const isAppRouter = !pagesRouter;
    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);
    const config = (0, _react.useMemo)(()=>{
        const c = configEnv || configContext || _imageconfig.imageConfigDefault;
        const allSizes = [
            ...c.deviceSizes,
            ...c.imageSizes
        ].sort((a, b)=>a - b);
        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);
        const qualities = c.qualities?.sort((a, b)=>a - b);
        return {
            ...c,
            allSizes,
            deviceSizes,
            qualities,
            // During the SSR, configEnv (__NEXT_IMAGE_OPTS) does not include
            // security sensitive configs like `localPatterns`, which is needed
            // during the server render to ensure it's validated. Therefore use
            // configContext, which holds the config from the server for validation.
            localPatterns: typeof window === 'undefined' ? configContext?.localPatterns : c.localPatterns
        };
    }, [
        configContext
    ]);
    const { onLoad, onLoadingComplete } = props;
    const onLoadRef = (0, _react.useRef)(onLoad);
    (0, _react.useEffect)(()=>{
        onLoadRef.current = onLoad;
    }, [
        onLoad
    ]);
    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);
    (0, _react.useEffect)(()=>{
        onLoadingCompleteRef.current = onLoadingComplete;
    }, [
        onLoadingComplete
    ]);
    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);
    const [showAltText, setShowAltText] = (0, _react.useState)(false);
    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {
        defaultLoader: _imageloader.default,
        imgConf: config,
        blurComplete,
        showAltText
    });
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {
                ...imgAttributes,
                unoptimized: imgMeta.unoptimized,
                placeholder: imgMeta.placeholder,
                fill: imgMeta.fill,
                onLoadRef: onLoadRef,
                onLoadingCompleteRef: onLoadingCompleteRef,
                setBlurComplete: setBlurComplete,
                setShowAltText: setShowAltText,
                sizesInput: props.sizes,
                ref: forwardedRef
            }),
            imgMeta.preload ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {
                isAppRouter: isAppRouter,
                imgAttributes: imgAttributes
            }) : null
        ]
    });
});
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=image-component.js.map
}),
"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
            case REACT_VIEW_TRANSITION_TYPE:
                return "ViewTransition";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
        var refProp = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, maybeKey, getOwner(), debugStack, debugTask);
    }
    function validateChildKeys(node) {
        isValidElement(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
    }
    function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    React = {
        react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        if (trackActualOwner) {
            var previousStackTraceLimit = Error.stackTraceLimit;
            Error.stackTraceLimit = 10;
            var debugStackDEV = Error("react-stack-top-frame");
            Error.stackTraceLimit = previousStackTraceLimit;
        } else debugStackDEV = unknownOwnerDebugStack;
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStackDEV, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
}();
}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}),
"[project]/node_modules/next/dist/shared/lib/image-external.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    default: null,
    getImageProps: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    getImageProps: function() {
        return getImageProps;
    }
});
const _interop_require_default = __turbopack_context__.r("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _getimgprops = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/get-img-props.js [app-client] (ecmascript)");
const _imagecomponent = __turbopack_context__.r("[project]/node_modules/next/dist/client/image-component.js [app-client] (ecmascript)");
const _imageloader = /*#__PURE__*/ _interop_require_default._(__turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-loader.js [app-client] (ecmascript)"));
function getImageProps(imgProps) {
    const { props } = (0, _getimgprops.getImgProps)(imgProps, {
        defaultLoader: _imageloader.default,
        // This is replaced by webpack define plugin
        imgConf: ("TURBOPACK compile-time value", {
            "deviceSizes": ("TURBOPACK compile-time value", [
                ("TURBOPACK compile-time value", 640),
                ("TURBOPACK compile-time value", 750),
                ("TURBOPACK compile-time value", 828),
                ("TURBOPACK compile-time value", 1080),
                ("TURBOPACK compile-time value", 1200),
                ("TURBOPACK compile-time value", 1920),
                ("TURBOPACK compile-time value", 2048),
                ("TURBOPACK compile-time value", 3840)
            ]),
            "imageSizes": ("TURBOPACK compile-time value", [
                ("TURBOPACK compile-time value", 32),
                ("TURBOPACK compile-time value", 48),
                ("TURBOPACK compile-time value", 64),
                ("TURBOPACK compile-time value", 96),
                ("TURBOPACK compile-time value", 128),
                ("TURBOPACK compile-time value", 256),
                ("TURBOPACK compile-time value", 384)
            ]),
            "qualities": ("TURBOPACK compile-time value", [
                ("TURBOPACK compile-time value", 75)
            ]),
            "path": ("TURBOPACK compile-time value", "/_next/image"),
            "loader": ("TURBOPACK compile-time value", "default"),
            "dangerouslyAllowSVG": ("TURBOPACK compile-time value", false),
            "unoptimized": ("TURBOPACK compile-time value", true),
            "domains": ("TURBOPACK compile-time value", []),
            "remotePatterns": ("TURBOPACK compile-time value", []),
            "localPatterns": ("TURBOPACK compile-time value", [
                ("TURBOPACK compile-time value", {
                    "pathname": ("TURBOPACK compile-time value", "**"),
                    "search": ("TURBOPACK compile-time value", "")
                })
            ]),
            "output": ("TURBOPACK compile-time value", "export")
        })
    });
    // Normally we don't care about undefined props because we pass to JSX,
    // but this exported function could be used by the end user for anything
    // so we delete undefined props to clean it up a little.
    for (const [key, value] of Object.entries(props)){
        if (value === undefined) {
            delete props[key];
        }
    }
    return {
        props
    };
}
const _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map
}),
"[project]/node_modules/next/image.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/shared/lib/image-external.js [app-client] (ecmascript)");
}),
"[project]/node_modules/splide-nextjs/splide/dist/js/splide.esm.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
 * Splide.js
 * Version  : 2.4.20
 * License  : MIT
 * Copyright: 2020 Naotoshi Fujita
 */ (function webpackUniversalModuleDefinition(root, factory) {
    if ("TURBOPACK compile-time truthy", 1) module.exports = factory();
    else //TURBOPACK unreachable
    ;
})(self, function() {
    return /******/ (()=>{
        /******/ "use strict";
        /******/ var __webpack_modules__ = {
            /***/ 311: (__unused_webpack_module, __webpack_exports__, __webpack_require__)=>{
                // ESM COMPAT FLAG
                __webpack_require__.r(__webpack_exports__);
                // EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "default": ()=>/* binding */ module_Splide
                });
                // NAMESPACE OBJECT: ./src/js/constants/states.js
                var states_namespaceObject = {};
                __webpack_require__.r(states_namespaceObject);
                __webpack_require__.d(states_namespaceObject, {
                    "CREATED": ()=>CREATED,
                    "DESTROYED": ()=>DESTROYED,
                    "IDLE": ()=>IDLE,
                    "MOUNTED": ()=>MOUNTED,
                    "MOVING": ()=>MOVING
                });
                ; // CONCATENATED MODULE: ./src/js/core/event.js
                /**
 * The function for providing an Event object simply managing events.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The function for providing an Event object simply managing events.
 */ /* harmony default export */ const core_event = function() {
                    /**
   * Store all event data.
   *
   * @type {Array}
   */ var data = [];
                    var Event = {
                        /**
     * Subscribe the given event(s).
     *
     * @param {string}   events  - An event name. Use space to separate multiple events.
     *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.
     * @param {function} handler - A callback function.
     * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.
     * @param {Object}   options - Optional. Options for addEventListener.
     */ on: function on(events, handler, elm, options) {
                            if (elm === void 0) {
                                elm = null;
                            }
                            if (options === void 0) {
                                options = {};
                            }
                            events.split(' ').forEach(function(event) {
                                if (elm) {
                                    elm.addEventListener(event, handler, options);
                                }
                                data.push({
                                    event: event,
                                    handler: handler,
                                    elm: elm,
                                    options: options
                                });
                            });
                        },
                        /**
     * Unsubscribe the given event(s).
     *
     * @param {string}  events - A event name or names split by space.
     * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.
     */ off: function off(events, elm) {
                            if (elm === void 0) {
                                elm = null;
                            }
                            events.split(' ').forEach(function(event) {
                                data = data.filter(function(item) {
                                    if (item && item.event === event && item.elm === elm) {
                                        unsubscribe(item);
                                        return false;
                                    }
                                    return true;
                                });
                            });
                        },
                        /**
     * Emit an event.
     * This method is only for custom events.
     *
     * @param {string}  event - An event name.
     * @param {*}       args  - Any number of arguments passed to handlers.
     */ emit: function emit(event) {
                            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                                args[_key - 1] = arguments[_key];
                            }
                            data.forEach(function(item) {
                                if (!item.elm && item.event.split('.')[0] === event) {
                                    item.handler.apply(item, args);
                                }
                            });
                        },
                        /**
     * Clear event data.
     */ destroy: function destroy() {
                            data.forEach(unsubscribe);
                            data = [];
                        }
                    };
                    /**
   * Remove the registered event listener.
   *
   * @param {Object} item - An object containing event data.
   */ function unsubscribe(item) {
                        if (item.elm) {
                            item.elm.removeEventListener(item.event, item.handler, item.options);
                        }
                    }
                    return Event;
                };
                ; // CONCATENATED MODULE: ./src/js/core/state.js
                /**
 * The function providing a super simple state system.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The function providing a super simple state system.
 *
 * @param {string|number} initialState - Provide the initial state value.
 */ /* harmony default export */ const state = function(initialState) {
                    /**
   * Store the current state.
   *
   * @type {string|number}
   */ var curr = initialState;
                    return {
                        /**
     * Change state.
     *
     * @param {string|number} state - A new state.
     */ set: function set(state) {
                            curr = state;
                        },
                        /**
     * Verify if the current state is given one or not.
     *
     * @param {string|number} state - A state name to be verified.
     *
     * @return {boolean} - True if the current state is the given one.
     */ is: function is(state) {
                            return state === curr;
                        }
                    };
                };
                ; // CONCATENATED MODULE: ./src/js/utils/object.js
                function _extends() {
                    _extends = Object.assign || function(target) {
                        for(var i = 1; i < arguments.length; i++){
                            var source = arguments[i];
                            for(var key in source){
                                if (Object.prototype.hasOwnProperty.call(source, key)) {
                                    target[key] = source[key];
                                }
                            }
                        }
                        return target;
                    };
                    return _extends.apply(this, arguments);
                }
                /**
 * Some utility functions related with Object, supporting IE.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ var keys = Object.keys;
                /**
 * Iterate an object like Array.forEach.
 * IE doesn't support forEach of HTMLCollection.
 *
 * @param {Object}    obj       - An object.
 * @param {function}  callback  - A function handling each value. Arguments are value, property and index.
 */ function each(obj, callback) {
                    keys(obj).some(function(key, index) {
                        return callback(obj[key], key, index);
                    });
                }
                /**
 * Return values of the given object as an array.
 * IE doesn't support Object.values.
 *
 * @param {Object} obj - An object.
 *
 * @return {Array} - An array containing all values of the given object.
 */ function values(obj) {
                    return keys(obj).map(function(key) {
                        return obj[key];
                    });
                }
                /**
 * Check if the given subject is object or not.
 *
 * @param {*} subject - A subject to be verified.
 *
 * @return {boolean} - True if object, false otherwise.
 */ function isObject(subject) {
                    return typeof subject === 'object';
                }
                /**
 * Merge two objects deeply.
 *
 * @param {Object} to   - An object where "from" is merged.
 * @param {Object} from - An object merged to "to".
 *
 * @return {Object} - A merged object.
 */ function merge(_ref, from) {
                    var to = _extends({}, _ref);
                    each(from, function(value, key) {
                        if (isObject(value)) {
                            if (!isObject(to[key])) {
                                to[key] = {};
                            }
                            to[key] = merge(to[key], value);
                        } else {
                            to[key] = value;
                        }
                    });
                    return to;
                }
                /**
 * Assign all properties "from" to "to" object.
 *
 * @param {Object} to   - An object where properties are assigned.
 * @param {Object} from - An object whose properties are assigned to "to".
 *
 * @return {Object} - An assigned object.
 */ function object_assign(to, from) {
                    keys(from).forEach(function(key) {
                        if (!to[key]) {
                            Object.defineProperty(to, key, Object.getOwnPropertyDescriptor(from, key));
                        }
                    });
                    return to;
                }
                ; // CONCATENATED MODULE: ./src/js/utils/utils.js
                /**
 * A package of some miscellaneous utility functions.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Convert the given value to array.
 *
 * @param {*} value - Any value.
 *
 * @return {*[]} - Array containing the given value.
 */ function toArray(value) {
                    return Array.isArray(value) ? value : [
                        value
                    ];
                }
                /**
 * Check if the given value is between min and max.
 * Min will be returned when the value is less than min or max will do when greater than max.
 *
 * @param {number} value - A number to be checked.
 * @param {number} m1    - Minimum or maximum number.
 * @param {number} m2    - Maximum or minimum number.
 *
 * @return {number} - A value itself, min or max.
 */ function between(value, m1, m2) {
                    return Math.min(Math.max(value, m1 > m2 ? m2 : m1), m1 > m2 ? m1 : m2);
                }
                /**
 * The sprintf method with minimum functionality.
 *
 * @param {string}       format       - The string format.
 * @param {string|Array} replacements - Replacements accepting multiple arguments.
 *
 * @returns {string} - Converted string.
 */ function sprintf(format, replacements) {
                    var i = 0;
                    return format.replace(/%s/g, function() {
                        return toArray(replacements)[i++];
                    });
                }
                /**
 * Append px unit to the given subject if necessary.
 *
 * @param {number|string} value - A value that may not include an unit.
 *
 * @return {string} - If the value is string, return itself.
 *                    If number, do value + "px". An empty string, otherwise.
 */ function unit(value) {
                    var type = typeof value;
                    if (type === 'number' && value > 0) {
                        return parseFloat(value) + 'px';
                    }
                    return type === 'string' ? value : '';
                }
                /**
 * Pad start with 0.
 *
 * @param {number} number - A number to be filled with 0.
 *
 * @return {string|number} - Padded number.
 */ function pad(number) {
                    return number < 10 ? '0' + number : number;
                }
                /**
 * Convert the given value to pixel.
 *
 * @param {Element}       root  - Root element where a dummy div is appended.
 * @param {string|number} value - CSS value to be converted, such as 10rem.
 *
 * @return {number} - Pixel.
 */ function toPixel(root, value) {
                    if (typeof value === 'string') {
                        var div = create('div', {});
                        applyStyle(div, {
                            position: 'absolute',
                            width: value
                        });
                        append(root, div);
                        value = div.clientWidth;
                        dom_remove(div);
                    }
                    return +value || 0;
                }
                ; // CONCATENATED MODULE: ./src/js/utils/dom.js
                /**
 * Some utility functions related with DOM.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Find the first element matching the given selector.
 * Be aware that all selectors after a space are ignored.
 *
 * @param {Element|Node}  elm       - An ancestor element.
 * @param {string}        selector  - DOMString.
 *
 * @return {Element|null} - A found element or null.
 */ function find(elm, selector) {
                    return elm ? elm.querySelector(selector.split(' ')[0]) : null;
                }
                /**
 * Find a first child having the given tag or class name.
 *
 * @param {Element} parent         - A parent element.
 * @param {string}  tagOrClassName - A tag or class name.
 *
 * @return {Element|undefined} - A found element on success or undefined on failure.
 */ function child(parent, tagOrClassName) {
                    return children(parent, tagOrClassName)[0];
                }
                /**
 * Return chile elements that matches the provided tag or class name.
 *
 * @param {Element} parent         - A parent element.
 * @param {string}  tagOrClassName - A tag or class name.
 *
 * @return {Element[]} - Found elements.
 */ function children(parent, tagOrClassName) {
                    if (parent) {
                        return values(parent.children).filter(function(child) {
                            return hasClass(child, tagOrClassName.split(' ')[0]) || child.tagName === tagOrClassName;
                        });
                    }
                    return [];
                }
                /**
 * Create an element with some optional attributes.
 *
 * @param {string} tag   - A tag name.
 * @param {Object} attrs - An object any attribute pairs of name and value.
 *
 * @return {Element} - A created element.
 */ function create(tag, attrs) {
                    var elm = document.createElement(tag);
                    each(attrs, function(value, key) {
                        return setAttribute(elm, key, value);
                    });
                    return elm;
                }
                /**
 * Convert HTML string to DOM node.
 *
 * @param {string} html - HTML string.
 *
 * @return {Node} - A created node.
 */ function domify(html) {
                    var div = create('div', {});
                    div.innerHTML = html;
                    return div.firstChild;
                }
                /**
 * Remove a given element from a DOM tree.
 *
 * @param {Element|Element[]} elms - Element(s) to be removed.
 */ function dom_remove(elms) {
                    toArray(elms).forEach(function(elm) {
                        if (elm) {
                            var parent = elm.parentElement;
                            parent && parent.removeChild(elm);
                        }
                    });
                }
                /**
 * Append a child to a given element.
 *
 * @param {Element} parent - A parent element.
 * @param {Element} child  - An element to be appended.
 */ function append(parent, child) {
                    if (parent) {
                        parent.appendChild(child);
                    }
                }
                /**
 * Insert an element before the reference element.
 *
 * @param {Element|Node} ref - A reference element.
 * @param {Element}      elm - An element to be inserted.
 */ function before(elm, ref) {
                    if (elm && ref) {
                        var parent = ref.parentElement;
                        parent && parent.insertBefore(elm, ref);
                    }
                }
                /**
 * Apply styles to the given element.
 *
 * @param {Element} elm     - An element where styles are applied.
 * @param {Object}  styles  - Object containing styles.
 */ function applyStyle(elm, styles) {
                    if (elm) {
                        each(styles, function(value, prop) {
                            if (value !== null) {
                                elm.style[prop] = value;
                            }
                        });
                    }
                }
                /**
 * Add or remove classes to/from the element.
 * This function is for internal usage.
 *
 * @param {Element}         elm     - An element where classes are added.
 * @param {string|string[]} classes - Class names being added.
 * @param {boolean}         remove  - Whether to remove or add classes.
 */ function addOrRemoveClasses(elm, classes, remove) {
                    if (elm) {
                        toArray(classes).forEach(function(name) {
                            if (name) {
                                elm.classList[remove ? 'remove' : 'add'](name);
                            }
                        });
                    }
                }
                /**
 * Add classes to the element.
 *
 * @param {Element}          elm     - An element where classes are added.
 * @param {string|string[]}  classes - Class names being added.
 */ function addClass(elm, classes) {
                    addOrRemoveClasses(elm, classes, false);
                }
                /**
 * Remove a class from the element.
 *
 * @param {Element}         elm     - An element where classes are removed.
 * @param {string|string[]} classes - A class name being removed.
 */ function removeClass(elm, classes) {
                    addOrRemoveClasses(elm, classes, true);
                }
                /**
 * Verify if the provided element has the class or not.
 *
 * @param {Element} elm       - An element.
 * @param {string}  className - A class name.
 *
 * @return {boolean} - True if the element has the class or false if not.
 */ function hasClass(elm, className) {
                    return !!elm && elm.classList.contains(className);
                }
                /**
 * Set attribute to the given element.
 *
 * @param {Element}                 elm   - An element where an attribute is assigned.
 * @param {string}                  name  - Attribute name.
 * @param {string|number|boolean}   value - Attribute value.
 */ function setAttribute(elm, name, value) {
                    if (elm) {
                        elm.setAttribute(name, value);
                    }
                }
                /**
 * Get attribute from the given element.
 *
 * @param {Element} elm  - An element where an attribute is assigned.
 * @param {string}  name - Attribute name.
 *
 * @return {string} - The value of the given attribute if available. An empty string if not.
 */ function getAttribute(elm, name) {
                    return elm ? elm.getAttribute(name) : '';
                }
                /**
 * Remove attribute from the given element.
 *
 * @param {Element|Element[]} elms  - An element where an attribute is removed.
 * @param {string|string[]}      names - Attribute name.
 */ function removeAttribute(elms, names) {
                    toArray(names).forEach(function(name) {
                        toArray(elms).forEach(function(elm) {
                            return elm && elm.removeAttribute(name);
                        });
                    });
                }
                /**
 * Return the Rect object of the provided object.
 *
 * @param {Element} elm - An element.
 *
 * @return {ClientRect|DOMRect} - A rect object.
 */ function getRect(elm) {
                    return elm.getBoundingClientRect();
                }
                /**
 * Trigger the given callback after all images contained by the element are loaded.
 *
 * @param {Element}  elm      - Element that may contain images.
 * @param {Function} callback - Callback function fired right after all images are loaded.
 */ function loaded(elm, callback) {
                    var images = elm.querySelectorAll('img');
                    var length = images.length;
                    if (length) {
                        var count = 0;
                        each(images, function(img) {
                            img.onload = img.onerror = function() {
                                if (++count === length) {
                                    callback();
                                }
                            };
                        });
                    } else {
                        // Trigger the callback immediately if there is no image.
                        callback();
                    }
                }
                ; // CONCATENATED MODULE: ./src/js/constants/types.js
                /**
 * Export slider types.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Normal slider.
 *
 * @type {string}
 */ var SLIDE = 'slide';
                /**
 * Loop after the last slide and before the first one.
 *
 * @type {string}
 */ var LOOP = 'loop';
                /**
 * The track doesn't move.
 *
 * @type {string}
 */ var FADE = 'fade';
                ; // CONCATENATED MODULE: ./src/js/transitions/slide/index.js
                /**
 * The component for general slide effect transition.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The component for general slide effect transition.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const slide = function(Splide, Components) {
                    /**
   * Hold the list element.
   *
   * @type {Element}
   */ var list;
                    /**
   * Hold the onEnd callback function.
   *
   * @type {function}
   */ var endCallback;
                    return {
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            list = Components.Elements.list;
                            Splide.on('transitionend', function(e) {
                                if (e.target === list && endCallback) {
                                    endCallback();
                                }
                            }, list);
                        },
                        /**
     * Start transition.
     *
     * @param {number}   destIndex - Destination slide index that might be clone's.
     * @param {number}   newIndex  - New index.
     * @param {number}   prevIndex - Previous index.
     * @param {Object}   coord     - Destination coordinates.
     * @param {function} done      - Callback function must be invoked when transition is completed.
     */ start: function start(destIndex, newIndex, prevIndex, coord, done) {
                            var options = Splide.options;
                            var edgeIndex = Components.Controller.edgeIndex;
                            var speed = options.speed;
                            endCallback = done;
                            if (Splide.is(SLIDE)) {
                                if (prevIndex === 0 && newIndex >= edgeIndex || prevIndex >= edgeIndex && newIndex === 0) {
                                    speed = options.rewindSpeed || speed;
                                }
                            }
                            applyStyle(list, {
                                transition: "transform " + speed + "ms " + options.easing,
                                transform: "translate(" + coord.x + "px," + coord.y + "px)"
                            });
                        }
                    };
                };
                ; // CONCATENATED MODULE: ./src/js/transitions/fade/index.js
                /**
 * The component for fade transition.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The component for fade transition.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const fade = function(Splide, Components) {
                    var Fade = {
                        /**
     * Called when the component is mounted.
     * Apply transition style to the first slide.
     */ mount: function mount() {
                            apply(Splide.index);
                        },
                        /**
     * Start transition.
     *
     * @param {number}    destIndex - Destination slide index that might be clone's.
     * @param {number}    newIndex  - New index.
     * @param {number}    prevIndex - Previous index.
     * @param {Object}    coord     - Destination coordinates.
     * @param {function}  done      - Callback function must be invoked when transition is completed.
     */ start: function start(destIndex, newIndex, prevIndex, coord, done) {
                            var track = Components.Elements.track;
                            applyStyle(track, {
                                height: unit(track.clientHeight)
                            });
                            apply(newIndex);
                            setTimeout(function() {
                                done();
                                applyStyle(track, {
                                    height: ''
                                });
                            });
                        }
                    };
                    /**
   * Apply transition style to the slide specified by the given index.
   *
   * @param {number} index - A slide index.
   */ function apply(index) {
                        var options = Splide.options;
                        applyStyle(Components.Elements.slides[index], {
                            transition: "opacity " + options.speed + "ms " + options.easing
                        });
                    }
                    return Fade;
                };
                ; // CONCATENATED MODULE: ./src/js/transitions/index.js
                /**
 * Export transition components.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ ; // CONCATENATED MODULE: ./src/js/core/composer.js
                /**
 * Provide a function for composing components.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Compose components.
 *
 * @param {Splide}   Splide     - Splide instance.
 * @param {Object}   Components - Additional components.
 * @param {function} Transition - Change component for transition.
 *
 * @return {Object} - An object containing all components.
 */ function compose(Splide, Components, Transition) {
                    var components = {};
                    each(Components, function(Component, name) {
                        components[name] = Component(Splide, components, name.toLowerCase());
                    });
                    if (!Transition) {
                        Transition = Splide.is(FADE) ? fade : slide;
                    }
                    components.Transition = Transition(Splide, components);
                    return components;
                }
                ; // CONCATENATED MODULE: ./src/js/utils/error.js
                /**
 * Utility functions for outputting logs.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Prefix of an error massage.
 *
 * @type {string}
 */ var MESSAGE_PREFIX = '[SPLIDE]';
                /**
 * Display an error message on the browser console.
 *
 * @param {string} message - An error message.
 */ function error(message) {
                    console.error(MESSAGE_PREFIX + " " + message);
                }
                /**
 * Check existence of the given object and throw an error if it doesn't.
 *
 * @throws {Error}
 *
 * @param {*}      subject - A subject to be confirmed.
 * @param {string} message - An error message.
 */ function exist(subject, message) {
                    if (!subject) {
                        throw new Error(message);
                    }
                }
                ; // CONCATENATED MODULE: ./src/js/constants/classes.js
                /**
 * Export class names.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * A root class name.
 *
 * @type {string}
 */ var ROOT = 'splide';
                /**
 * The definition table of all classes for elements.
 * They might be modified by options.
 *
 * @type {Object}
 */ var ELEMENT_CLASSES = {
                    root: ROOT,
                    slider: ROOT + "__slider",
                    track: ROOT + "__track",
                    list: ROOT + "__list",
                    slide: ROOT + "__slide",
                    container: ROOT + "__slide__container",
                    arrows: ROOT + "__arrows",
                    arrow: ROOT + "__arrow",
                    prev: ROOT + "__arrow--prev",
                    next: ROOT + "__arrow--next",
                    pagination: ROOT + "__pagination",
                    page: ROOT + "__pagination__page",
                    clone: ROOT + "__slide--clone",
                    progress: ROOT + "__progress",
                    bar: ROOT + "__progress__bar",
                    autoplay: ROOT + "__autoplay",
                    play: ROOT + "__play",
                    pause: ROOT + "__pause",
                    spinner: ROOT + "__spinner",
                    sr: ROOT + "__sr"
                };
                /**
 * Definitions of status classes.
 *
 * @type {Object}
 */ var STATUS_CLASSES = {
                    active: 'is-active',
                    visible: 'is-visible',
                    loading: 'is-loading'
                };
                ; // CONCATENATED MODULE: ./src/js/constants/i18n.js
                /**
 * Export i18n texts as object.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Texts for i18n.
 *
 * @type {Object}
 */ var I18N = {
                    prev: 'Previous slide',
                    next: 'Next slide',
                    first: 'Go to first slide',
                    last: 'Go to last slide',
                    slideX: 'Go to slide %s',
                    pageX: 'Go to page %s',
                    play: 'Start autoplay',
                    pause: 'Pause autoplay'
                };
                ; // CONCATENATED MODULE: ./src/js/constants/defaults.js
                /**
 * Export default options.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ var DEFAULTS = {
                    /**
   * Determine a slider type.
   * - 'slide': Regular slider.
   * - 'loop' : Carousel slider.
   * - 'fade' : Change slides with fade transition. perPage, drag options are ignored.
   *
   * @type {string}
   */ type: 'slide',
                    /**
   * Whether to rewind a slider before the first slide or after the last one.
   * In "loop" mode, this option is ignored.
   *
   * @type {boolean}
   */ rewind: false,
                    /**
   * Transition speed in milliseconds.
   *
   * @type {number}
   */ speed: 400,
                    /**
   * Transition speed on rewind in milliseconds.
   *
   * @type {number}
   */ rewindSpeed: 0,
                    /**
   * Whether to prevent any actions while a slider is transitioning.
   * If false, navigation, drag and swipe work while the slider is running.
   * Even so, it will be forced to wait for transition in some cases in the loop mode to shift a slider.
   *
   * @type {boolean}
   */ waitForTransition: true,
                    /**
   * Define slider max width.
   *
   * @type {number}
   */ width: 0,
                    /**
   * Define slider height.
   *
   * @type {number}
   */ height: 0,
                    /**
   * Fix width of slides. CSS format is allowed such as 10em, 80% or 80vw.
   * perPage number will be ignored when this option is falsy.
   *
   * @type {number|string}
   */ fixedWidth: 0,
                    /**
   * Fix height of slides. CSS format is allowed such as 10em, 80vh but % unit is not accepted.
   * heightRatio option will be ignored when this option is falsy.
   *
   * @type {number|string}
   */ fixedHeight: 0,
                    /**
   * Determine height of slides by ratio to a slider width.
   * This will be ignored when the fixedHeight is provided.
   *
   * @type {number}
   */ heightRatio: 0,
                    /**
   * If true, slide width will be determined by the element width itself.
   * - perPage/perMove should be 1.
   *
   * @type {boolean}
   */ autoWidth: false,
                    /**
   * If true, slide height will be determined by the element width itself.
   * - perPage/perMove should be 1.
   *
   * @type {boolean}
   */ autoHeight: false,
                    /**
   * Determine how many slides should be displayed per page.
   *
   * @type {number}
   */ perPage: 1,
                    /**
   * Determine how many slides should be moved when a slider goes to next or perv.
   *
   * @type {number}
   */ perMove: 0,
                    /**
   * Determine manually how many clones should be generated on the left and right side.
   * The total number of clones will be twice of this number.
   *
   * @type {number}
   */ clones: 0,
                    /**
   * Start index.
   *
   * @type {number}
   */ start: 0,
                    /**
   * Determine which slide should be focused if there are multiple slides in a page.
   * A string "center" is acceptable for centering slides.
   *
   * @type {boolean|number|string}
   */ focus: false,
                    /**
   * Gap between slides. CSS format is allowed such as 1em.
   *
   * @type {number|string}
   */ gap: 0,
                    /**
   * Set padding-left/right in horizontal mode or padding-top/bottom in vertical one.
   * Give a single value to set a same size for both sides or
   * do an object for different sizes.
   * Also, CSS format is allowed such as 1em.
   *
   * @example
   * - 10: Number
   * - '1em': CSS format.
   * - { left: 0, right: 20 }: Object for different sizes in horizontal mode.
   * - { top: 0, bottom: 20 }: Object for different sizes in vertical mode.
   *
   * @type {number|string|Object}
   */ padding: 0,
                    /**
   * Whether to append arrows.
   *
   * @type {boolean}
   */ arrows: true,
                    /**
   * Change the arrow SVG path like 'm7.61 0.807-2.12...'.
   *
   * @type {string}
   */ arrowPath: '',
                    /**
   * Whether to append pagination(indicator dots) or not.
   *
   * @type {boolean}
   */ pagination: true,
                    /**
   * Activate autoplay.
   *
   * @type {boolean}
   */ autoplay: false,
                    /**
   * Autoplay interval in milliseconds.
   *
   * @type {number}
   */ interval: 5000,
                    /**
   * Whether to stop autoplay when a slider is hovered.
   *
   * @type {boolean}
   */ pauseOnHover: true,
                    /**
   * Whether to stop autoplay when a slider elements are focused.
   * True is recommended for accessibility.
   *
   * @type {boolean}
   */ pauseOnFocus: true,
                    /**
   * Whether to reset progress of the autoplay timer when resumed.
   *
   * @type {boolean}
   */ resetProgress: true,
                    /**
   * Loading images lazily.
   * Image src must be provided by a data-splide-lazy attribute.
   *
   * - false: Do nothing.
   * - 'nearby': Only images around an active slide will be loaded.
   * - 'sequential': All images will be sequentially loaded.
   *
   * @type {boolean|string}
   */ lazyLoad: false,
                    /**
   * This option works only when a lazyLoad option is "nearby".
   * Determine how many pages(not slides) around an active slide should be loaded beforehand.
   *
   * @type {number}
   */ preloadPages: 1,
                    /**
   * Easing for CSS transition. For example, linear, ease or cubic-bezier().
   *
   * @type {string}
   */ easing: 'cubic-bezier(.42,.65,.27,.99)',
                    /**
   * Whether to enable keyboard shortcuts
   * - true or 'global': Listen to keydown event of the document.
   * - 'focused': Listen to the keydown event of the slider root element. tabindex="0" will be added to the element.
   * - false: Disable keyboard shortcuts.
   *
   * @type {boolean|string}
   */ keyboard: 'global',
                    /**
   * Whether to allow mouse drag and touch swipe.
   *
   * @type {boolean}
   */ drag: true,
                    /**
   * The angle threshold for drag.
   * The slider starts moving only when the drag angle is less than this threshold.
   *
   * @type {number}
   */ dragAngleThreshold: 30,
                    /**
   * Distance threshold for determining if the action is "flick" or "swipe".
   * When a drag distance is over this value, the action will be treated as "swipe", not "flick".
   *
   * @type {number}
   */ swipeDistanceThreshold: 150,
                    /**
   * Velocity threshold for determining if the action is "flick" or "swipe".
   * Around 0.5 is recommended.
   *
   * @type {number}
   */ flickVelocityThreshold: .6,
                    /**
   * Determine power of flick. The larger number this is, the farther a slider runs by flick.
   * Around 500 is recommended.
   *
   * @type {number}
   */ flickPower: 600,
                    /**
   * Limit a number of pages to move by flick.
   *
   * @type {number}
   */ flickMaxPages: 1,
                    /**
   * Slider direction.
   * - 'ltr': Left to right.
   * - 'rtl': Right to left.
   * - 'ttb': Top to bottom.
   *
   * @type {string}
   */ direction: 'ltr',
                    /**
   * Set img src to background-image of its parent element.
   * Images with various sizes can be displayed as same dimension without cropping work.
   * fixedHeight or heightRatio is required.
   *
   * @type {boolean}
   */ cover: false,
                    /**
   * Whether to enable accessibility(aria and screen reader texts) or not.
   *
   * @type {boolean}
   */ accessibility: true,
                    /**
   * Whether to add tabindex="0" to visible slides or not.
   *
   * @type {boolean}
   */ slideFocus: true,
                    /**
   * Determine if a slider is navigation for another.
   * Use "sync" API to synchronize two sliders.
   *
   * @type {boolean}
   */ isNavigation: false,
                    /**
   * Whether to trim spaces before the fist slide or after the last one when "focus" is not 0.
   *
   * @type {boolean}
   */ trimSpace: true,
                    /**
   * The "is-active" class is added after transition as default.
   * If true, it will be added before move.
   *
   * @type {boolean}
   */ updateOnMove: false,
                    /**
   * Throttle duration in milliseconds for the resize event.
   *
   * @type {number}
   */ throttle: 100,
                    /**
   * Whether to destroy a slider or not.
   *
   * @type {boolean}
   */ destroy: false,
                    /**
   * Options for specific breakpoints.
   *
   * @example
   * {
   *   1000: {
   *     perPage: 3,
   *     gap: 20
   *   },
   *   600: {
   *     perPage: 1,
   *     gap: 5,
   *   }
   * }
   *
   * @type {boolean|Object}
   */ breakpoints: false,
                    /**
   * Collection of class names.
   *
   * @see ./classes.js
   *
   * @type {Object}
   */ classes: ELEMENT_CLASSES,
                    /**
   * Collection of i18n texts.
   *
   * @see ./i18n.js
   *
   * @type {Object}
   */ i18n: I18N
                };
                ; // CONCATENATED MODULE: ./src/js/constants/states.js
                /**
 * Export state constants.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Splide has been just created.
 *
 * @type {number}
 */ var CREATED = 1;
                /**
 * All components have been mounted and initialized.
 *
 * @type {number}
 */ var MOUNTED = 2;
                /**
 * Splide is ready for transition.
 *
 * @type {number}
 */ var IDLE = 3;
                /**
 * Splide is moving.
 *
 * @type {number}
 */ var MOVING = 4;
                /**
 * Splide is moving.
 *
 * @type {number}
 */ var DESTROYED = 5;
                ; // CONCATENATED MODULE: ./src/js/splide.js
                function _defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    return Constructor;
                }
                /**
 * The main class for applying Splide to an element.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The main class for applying Splide to an element,
 * providing some APIs to control the behavior.
 */ var Splide = /*#__PURE__*/ function() {
                    /**
   * Splide constructor.
   *
   * @throws {Error} When the given root element or selector is invalid.
   *
   * @param {Element|string}  root       - A selector for a root element or an element itself.
   * @param {Object}          options    - Optional. Options to change default behaviour.
   * @param {Object}          Components - Optional. Components.
   */ function Splide(root, options, Components) {
                        if (options === void 0) {
                            options = {};
                        }
                        if (Components === void 0) {
                            Components = {};
                        }
                        this.root = root instanceof Element ? root : document.querySelector(root);
                        exist(this.root, 'An invalid element/selector was given.');
                        this.Components = null;
                        this.Event = core_event();
                        this.State = state(CREATED);
                        this.STATES = states_namespaceObject;
                        this._o = merge(DEFAULTS, options);
                        this._i = 0;
                        this._c = Components;
                        this._e = {}; // Extensions
                        this._t = null; // Transition
                    }
                    /**
   * Compose and mount components.
   *
   * @param {Object}   Extensions - Optional. Additional components.
   * @param {function} Transition - Optional. Set a custom transition component.
   *
   * @return {Splide|undefined} - This instance or undefined if an exception occurred.
   */ var _proto = Splide.prototype;
                    _proto.mount = function mount(Extensions, Transition) {
                        var _this = this;
                        if (Extensions === void 0) {
                            Extensions = this._e;
                        }
                        if (Transition === void 0) {
                            Transition = this._t;
                        }
                        // Reset the state.
                        this.State.set(CREATED);
                        this._e = Extensions;
                        this._t = Transition;
                        this.Components = compose(this, merge(this._c, Extensions), Transition);
                        try {
                            each(this.Components, function(component, key) {
                                var required = component.required;
                                if (required === undefined || required) {
                                    component.mount && component.mount();
                                } else {
                                    delete _this.Components[key];
                                }
                            });
                        } catch (e) {
                            error(e.message);
                            return;
                        }
                        var State = this.State;
                        State.set(MOUNTED);
                        each(this.Components, function(component) {
                            component.mounted && component.mounted();
                        });
                        this.emit('mounted');
                        State.set(IDLE);
                        this.emit('ready');
                        applyStyle(this.root, {
                            visibility: 'visible'
                        });
                        this.on('move drag', function() {
                            return State.set(MOVING);
                        }).on('moved dragged', function() {
                            return State.set(IDLE);
                        });
                        return this;
                    };
                    _proto.sync = function sync(splide) {
                        this.sibling = splide;
                        return this;
                    };
                    _proto.on = function on(events, handler, elm, options) {
                        if (elm === void 0) {
                            elm = null;
                        }
                        if (options === void 0) {
                            options = {};
                        }
                        this.Event.on(events, handler, elm, options);
                        return this;
                    };
                    _proto.off = function off(events, elm) {
                        if (elm === void 0) {
                            elm = null;
                        }
                        this.Event.off(events, elm);
                        return this;
                    };
                    _proto.emit = function emit(event) {
                        var _this$Event;
                        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                            args[_key - 1] = arguments[_key];
                        }
                        (_this$Event = this.Event).emit.apply(_this$Event, [
                            event
                        ].concat(args));
                        return this;
                    };
                    _proto.go = function go(control, wait) {
                        if (wait === void 0) {
                            wait = this.options.waitForTransition;
                        }
                        if (this.State.is(IDLE) || this.State.is(MOVING) && !wait) {
                            this.Components.Controller.go(control, false);
                        }
                        return this;
                    };
                    _proto.is = function is(type) {
                        return type === this._o.type;
                    };
                    _proto.add = function add(slide, index) {
                        if (index === void 0) {
                            index = -1;
                        }
                        this.Components.Elements.add(slide, index, this.refresh.bind(this));
                        return this;
                    };
                    _proto.remove = function remove(index) {
                        this.Components.Elements.remove(index);
                        this.refresh();
                        return this;
                    };
                    _proto.refresh = function refresh() {
                        this.emit('refresh:before').emit('refresh').emit('resize');
                        return this;
                    };
                    _proto.destroy = function destroy(completely) {
                        var _this2 = this;
                        if (completely === void 0) {
                            completely = true;
                        }
                        // Postpone destroy because it should be done after mount.
                        if (this.State.is(CREATED)) {
                            this.on('ready', function() {
                                return _this2.destroy(completely);
                            });
                            return;
                        }
                        values(this.Components).reverse().forEach(function(component) {
                            component.destroy && component.destroy(completely);
                        });
                        this.emit('destroy', completely); // Destroy all event handlers, including ones for native events.
                        this.Event.destroy();
                        this.State.set(DESTROYED);
                        return this;
                    };
                    _createClass(Splide, [
                        {
                            key: "index",
                            get: function get() {
                                return this._i;
                            },
                            set: function set(index) {
                                this._i = parseInt(index);
                            }
                        },
                        {
                            key: "length",
                            get: function get() {
                                return this.Components.Elements.length;
                            }
                        },
                        {
                            key: "options",
                            get: function get() {
                                return this._o;
                            },
                            set: function set(options) {
                                var created = this.State.is(CREATED);
                                if (!created) {
                                    this.emit('update');
                                }
                                this._o = merge(this._o, options);
                                if (!created) {
                                    this.emit('updated', this._o);
                                }
                            }
                        },
                        {
                            key: "classes",
                            get: function get() {
                                return this._o.classes;
                            }
                        },
                        {
                            key: "i18n",
                            get: function get() {
                                return this._o.i18n;
                            }
                        }
                    ]);
                    return Splide;
                }();
                ; // CONCATENATED MODULE: ./src/js/components/options/index.js
                /**
 * The component for initializing options.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The component for initializing options.
 *
 * @param {Splide} Splide - A Splide instance.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const options = function(Splide) {
                    /**
   * Retrieve options from the data attribute.
   * Note that IE10 doesn't support dataset property.
   *
   * @type {string}
   */ var options = getAttribute(Splide.root, 'data-splide');
                    if (options) {
                        try {
                            Splide.options = JSON.parse(options);
                        } catch (e) {
                            error(e.message);
                        }
                    }
                    return {
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            if (Splide.State.is(CREATED)) {
                                Splide.index = Splide.options.start;
                            }
                        }
                    };
                };
                ; // CONCATENATED MODULE: ./src/js/constants/directions.js
                /**
 * Export layout modes.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Enumerate slides from left to right.
 *
 * @type {string}
 */ var LTR = 'ltr';
                /**
 * Enumerate slides from right to left.
 *
 * @type {string}
 */ var RTL = 'rtl';
                /**
 * Enumerate slides in a col.
 *
 * @type {string}
 */ var TTB = 'ttb';
                ; // CONCATENATED MODULE: ./src/js/components/elements/slide.js
                /**
 * The sub component for handling each slide.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Events for restoring original styles.
 *
 * @type {string}
 */ var STYLE_RESTORE_EVENTS = 'update.slide';
                /**
 * The sub component for handling each slide.
 *
 * @param {Splide}  Splide    - A Splide instance.
 * @param {number}  index     - An unique slide index.
 * @param {number}  realIndex - Clones should pass a real slide index.
 * @param {Element} slide     - A slide element.
 *
 * @return {Object} - The sub component object.
 */ /* harmony default export */ const elements_slide = function(Splide, index, realIndex, slide) {
                    /**
   * Whether to update "is-active" class before or after transition.
   *
   * @type {boolean}
   */ var updateOnMove = Splide.options.updateOnMove;
                    /**
   * Events when the slide status is updated.
   * Append a namespace to remove listeners later.
   *
   * @type {string}
   */ var STATUS_UPDATE_EVENTS = 'ready.slide updated.slide resized.slide moved.slide' + (updateOnMove ? ' move.slide' : '');
                    /**
   * Slide sub component object.
   *
   * @type {Object}
   */ var Slide = {
                        /**
     * Slide element.
     *
     * @type {Element}
     */ slide: slide,
                        /**
     * Slide index.
     *
     * @type {number}
     */ index: index,
                        /**
     * Real index for clones.
     *
     * @type {number}
     */ realIndex: realIndex,
                        /**
     * Container element if available.
     *
     * @type {Element|undefined}
     */ container: child(slide, Splide.classes.container),
                        /**
     * Whether this is a cloned slide or not.
     *
     * @type {boolean}
     */ isClone: realIndex > -1,
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            var _this = this;
                            if (!this.isClone) {
                                slide.id = Splide.root.id + "-slide" + pad(index + 1);
                            }
                            Splide.on(STATUS_UPDATE_EVENTS, function() {
                                return _this.update();
                            }).on(STYLE_RESTORE_EVENTS, restoreStyles).on('click', function() {
                                return Splide.emit('click', _this);
                            }, slide);
                            /*
       * Add "is-active" class to a clone element temporarily
       * and it will be removed on "moved" event.
       */ if (updateOnMove) {
                                Splide.on('move.slide', function(newIndex) {
                                    if (newIndex === realIndex) {
                                        _update(true, false);
                                    }
                                });
                            } // Make sure the slide is shown.
                            applyStyle(slide, {
                                display: ''
                            }); // Hold the original styles.
                            this.styles = getAttribute(slide, 'style') || '';
                        },
                        /**
     * Destroy.
     */ destroy: function destroy() {
                            Splide.off(STATUS_UPDATE_EVENTS).off(STYLE_RESTORE_EVENTS).off('click', slide);
                            removeClass(slide, values(STATUS_CLASSES));
                            restoreStyles();
                            removeAttribute(this.container, 'style');
                        },
                        /**
     * Update active and visible status.
     */ update: function update() {
                            _update(this.isActive(), false);
                            _update(this.isVisible(), true);
                        },
                        /**
     * Check whether this slide is active or not.
     *
     * @return {boolean} - True if the slide is active or false if not.
     */ isActive: function isActive() {
                            return Splide.index === index;
                        },
                        /**
     * Check whether this slide is visible in the viewport or not.
     *
     * @return {boolean} - True if the slide is visible or false if not.
     */ isVisible: function isVisible() {
                            var active = this.isActive();
                            if (Splide.is(FADE) || active) {
                                return active;
                            }
                            var ceil = Math.ceil;
                            var trackRect = getRect(Splide.Components.Elements.track);
                            var slideRect = getRect(slide);
                            if (Splide.options.direction === TTB) {
                                return trackRect.top <= slideRect.top && slideRect.bottom <= ceil(trackRect.bottom);
                            }
                            return trackRect.left <= slideRect.left && slideRect.right <= ceil(trackRect.right);
                        },
                        /**
     * Calculate how far this slide is from another slide and
     * return true if the distance is within the given number.
     *
     * @param {number} from   - Index of a target slide.
     * @param {number} within - True if the slide is within this number.
     *
     * @return {boolean} - True if the slide is within the number or false otherwise.
     */ isWithin: function isWithin(from, within) {
                            var diff = Math.abs(from - index);
                            if (!Splide.is(SLIDE) && !this.isClone) {
                                diff = Math.min(diff, Splide.length - diff);
                            }
                            return diff < within;
                        }
                    };
                    /**
   * Update classes for activity or visibility.
   *
   * @param {boolean} active        - Is active/visible or not.
   * @param {boolean} forVisibility - Toggle classes for activity or visibility.
   */ function _update(active, forVisibility) {
                        var type = forVisibility ? 'visible' : 'active';
                        var className = STATUS_CLASSES[type];
                        if (active) {
                            addClass(slide, className);
                            Splide.emit("" + type, Slide);
                        } else {
                            if (hasClass(slide, className)) {
                                removeClass(slide, className);
                                Splide.emit("" + (forVisibility ? 'hidden' : 'inactive'), Slide);
                            }
                        }
                    }
                    /**
   * Restore the original styles.
   */ function restoreStyles() {
                        setAttribute(slide, 'style', Slide.styles);
                    }
                    return Slide;
                };
                ; // CONCATENATED MODULE: ./src/js/components/elements/index.js
                /**
 * The component for main elements.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The property name for UID stored in a window object.
 *
 * @type {string}
 */ var UID_NAME = 'uid';
                /**
 * The component for main elements.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const components_elements = function(Splide, Components) {
                    /**
   * Hold the root element.
   *
   * @type {Element}
   */ var root = Splide.root;
                    /**
   * Hold the class list.
   *
   * @type {Object}
   */ var classes = Splide.classes;
                    /**
   * Store Slide objects.
   *
   * @type {Array}
   */ var Slides = [];
                    /*
   * Assign unique ID to the root element if it doesn't have the one.
   * Note that IE doesn't support padStart() to fill the uid by 0.
   */ if (!root.id) {
                        window.splide = window.splide || {};
                        var uid = window.splide[UID_NAME] || 0;
                        window.splide[UID_NAME] = ++uid;
                        root.id = "splide" + pad(uid);
                    }
                    /**
   * Elements component object.
   *
   * @type {Object}
   */ var Elements = {
                        /**
     * Called when the component is mounted.
     * Collect main elements and store them as member properties.
     */ mount: function mount() {
                            var _this = this;
                            this.init();
                            Splide.on('refresh', function() {
                                _this.destroy();
                                _this.init();
                            }).on('updated', function() {
                                removeClass(root, getClasses());
                                addClass(root, getClasses());
                            });
                        },
                        /**
     * Destroy.
     */ destroy: function destroy() {
                            Slides.forEach(function(Slide) {
                                Slide.destroy();
                            });
                            Slides = [];
                            removeClass(root, getClasses());
                        },
                        /**
     * Initialization.
     */ init: function init() {
                            var _this2 = this;
                            collect();
                            addClass(root, getClasses());
                            this.slides.forEach(function(slide, index) {
                                _this2.register(slide, index, -1);
                            });
                        },
                        /**
     * Register a slide to create a Slide object and handle its behavior.
     *
     * @param {Element} slide     - A slide element.
     * @param {number}  index     - A unique index. This can be negative.
     * @param {number}  realIndex - A real index for clones. Set -1 for real slides.
     */ register: function register(slide, index, realIndex) {
                            var SlideObject = elements_slide(Splide, index, realIndex, slide);
                            SlideObject.mount();
                            Slides.push(SlideObject);
                        },
                        /**
     * Return the Slide object designated by the index.
     * Note that "find" is not supported by IE.
     *
     * @return {Object|undefined} - A Slide object if available. Undefined if not.
     */ getSlide: function getSlide(index) {
                            return Slides.filter(function(Slide) {
                                return Slide.index === index;
                            })[0];
                        },
                        /**
     * Return all Slide objects.
     *
     * @param {boolean} includeClones - Whether to include cloned slides or not.
     *
     * @return {Object[]} - Slide objects.
     */ getSlides: function getSlides(includeClones) {
                            return includeClones ? Slides : Slides.filter(function(Slide) {
                                return !Slide.isClone;
                            });
                        },
                        /**
     * Return Slide objects belonging to the given page.
     *
     * @param {number} page - A page number.
     *
     * @return {Object[]} - An array containing Slide objects.
     */ getSlidesByPage: function getSlidesByPage(page) {
                            var idx = Components.Controller.toIndex(page);
                            var options = Splide.options;
                            var max = options.focus !== false ? 1 : options.perPage;
                            return Slides.filter(function(_ref) {
                                var index = _ref.index;
                                return idx <= index && index < idx + max;
                            });
                        },
                        /**
     * Insert a slide to a slider.
     * Need to refresh Splide after adding a slide.
     *
     * @param {Node|string} slide    - A slide element to be added.
     * @param {number}      index    - A slide will be added at the position.
     * @param {Function}    callback - Called right after the slide is added to the DOM tree.
     */ add: function add(slide, index, callback) {
                            if (typeof slide === 'string') {
                                slide = domify(slide);
                            }
                            if (slide instanceof Element) {
                                var ref = this.slides[index]; // This will be removed in mount() of a Slide component.
                                applyStyle(slide, {
                                    display: 'none'
                                });
                                if (ref) {
                                    before(slide, ref);
                                    this.slides.splice(index, 0, slide);
                                } else {
                                    append(this.list, slide);
                                    this.slides.push(slide);
                                }
                                loaded(slide, function() {
                                    callback && callback(slide);
                                });
                            }
                        },
                        /**
     * Remove a slide from a slider.
     * Need to refresh Splide after removing a slide.
     *
     * @param index - Slide index.
     */ remove: function remove(index) {
                            dom_remove(this.slides.splice(index, 1)[0]);
                        },
                        /**
     * Trigger the provided callback for each Slide object.
     *
     * @param {Function} callback - A callback function. The first argument will be the Slide object.
     */ each: function each(callback) {
                            Slides.forEach(callback);
                        },
                        /**
     * Return slides length without clones.
     *
     * @return {number} - Slide length.
     */ get length () {
                            return this.slides.length;
                        },
                        /**
     * Return "SlideObjects" length including clones.
     *
     * @return {number} - Slide length including clones.
     */ get total () {
                            return Slides.length;
                        }
                    };
                    /**
   * Collect elements.
   */ function collect() {
                        Elements.slider = child(root, classes.slider);
                        Elements.track = find(root, "." + classes.track);
                        Elements.list = child(Elements.track, classes.list);
                        exist(Elements.track && Elements.list, 'Track or list was not found.');
                        Elements.slides = children(Elements.list, classes.slide);
                        var arrows = findParts(classes.arrows);
                        Elements.arrows = {
                            prev: find(arrows, "." + classes.prev),
                            next: find(arrows, "." + classes.next)
                        };
                        var autoplay = findParts(classes.autoplay);
                        Elements.bar = find(findParts(classes.progress), "." + classes.bar);
                        Elements.play = find(autoplay, "." + classes.play);
                        Elements.pause = find(autoplay, "." + classes.pause);
                        Elements.track.id = Elements.track.id || root.id + "-track";
                        Elements.list.id = Elements.list.id || root.id + "-list";
                    }
                    /**
   * Return class names for the root element.
   */ function getClasses() {
                        var rootClass = classes.root;
                        var options = Splide.options;
                        return [
                            rootClass + "--" + options.type,
                            rootClass + "--" + options.direction,
                            options.drag ? rootClass + "--draggable" : '',
                            options.isNavigation ? rootClass + "--nav" : '',
                            STATUS_CLASSES.active
                        ];
                    }
                    /**
   * Find parts only from children of the root or track.
   *
   * @return {Element} - A found element or undefined.
   */ function findParts(className) {
                        return child(root, className) || child(Elements.slider, className);
                    }
                    return Elements;
                };
                ; // CONCATENATED MODULE: ./src/js/components/controller/index.js
                /**
 * The component for controlling the track.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ var floor = Math.floor;
                /**
 * The component for controlling the track.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const controller = function(Splide, Components) {
                    /**
   * Store current options.
   *
   * @type {Object}
   */ var options;
                    /**
   * True if the slide is LOOP mode.
   *
   * @type {boolean}
   */ var isLoop;
                    /**
   * Controller component object.
   *
   * @type {Object}
   */ var Controller = {
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            options = Splide.options;
                            isLoop = Splide.is(LOOP);
                            bind();
                        },
                        /**
     * Make track run by the given control.
     * - "+{i}" : Increment the slide index by i.
     * - "-{i}" : Decrement the slide index by i.
     * - "{i}"  : Go to the slide whose index is i.
     * - ">"    : Go to next page.
     * - "<"    : Go to prev page.
     * - ">{i}" : Go to page i.
     *
     * @param {string|number} control  - A control pattern.
     * @param {boolean}       silently - Go to the destination without event emission.
     */ go: function go(control, silently) {
                            var destIndex = this.trim(this.parse(control));
                            Components.Track.go(destIndex, this.rewind(destIndex), silently);
                        },
                        /**
     * Parse the given control and return the destination index for the track.
     *
     * @param {string} control - A control target pattern.
     *
     * @return {number} - A parsed target.
     */ parse: function parse(control) {
                            var index = Splide.index;
                            var matches = String(control).match(/([+\-<>]+)(\d+)?/);
                            var indicator = matches ? matches[1] : '';
                            var number = matches ? parseInt(matches[2]) : 0;
                            switch(indicator){
                                case '+':
                                    index += number || 1;
                                    break;
                                case '-':
                                    index -= number || 1;
                                    break;
                                case '>':
                                case '<':
                                    index = parsePage(number, index, indicator === '<');
                                    break;
                                default:
                                    index = parseInt(control);
                            }
                            return index;
                        },
                        /**
     * Compute index from the given page number.
     *
     * @param {number} page - Page number.
     *
     * @return {number} - A computed page number.
     */ toIndex: function toIndex(page) {
                            if (hasFocus()) {
                                return page;
                            }
                            var length = Splide.length;
                            var perPage = options.perPage;
                            var index = page * perPage;
                            index = index - (this.pageLength * perPage - length) * floor(index / length); // Adjustment for the last page.
                            if (length - perPage <= index && index < length) {
                                index = length - perPage;
                            }
                            return index;
                        },
                        /**
     * Compute page number from the given slide index.
     *
     * @param {number} index - Slide index.
     *
     * @return {number} - A computed page number.
     */ toPage: function toPage(index) {
                            if (hasFocus()) {
                                return index;
                            }
                            var length = Splide.length;
                            var perPage = options.perPage; // Make the last "perPage" number of slides belong to the last page.
                            if (length - perPage <= index && index < length) {
                                return floor((length - 1) / perPage);
                            }
                            return floor(index / perPage);
                        },
                        /**
     * Trim the given index according to the current mode.
     * Index being returned could be less than 0 or greater than the length in Loop mode.
     *
     * @param {number} index - An index being trimmed.
     *
     * @return {number} - A trimmed index.
     */ trim: function trim(index) {
                            if (!isLoop) {
                                index = options.rewind ? this.rewind(index) : between(index, 0, this.edgeIndex);
                            }
                            return index;
                        },
                        /**
     * Rewind the given index if it's out of range.
     *
     * @param {number} index - An index.
     *
     * @return {number} - A rewound index.
     */ rewind: function rewind(index) {
                            var edge = this.edgeIndex;
                            if (isLoop) {
                                while(index > edge){
                                    index -= edge + 1;
                                }
                                while(index < 0){
                                    index += edge + 1;
                                }
                            } else {
                                if (index > edge) {
                                    index = 0;
                                } else if (index < 0) {
                                    index = edge;
                                }
                            }
                            return index;
                        },
                        /**
     * Check if the direction is "rtl" or not.
     *
     * @return {boolean} - True if "rtl" or false if not.
     */ isRtl: function isRtl() {
                            return options.direction === RTL;
                        },
                        /**
     * Return the page length.
     *
     * @return {number} - Max page number.
     */ get pageLength () {
                            var length = Splide.length;
                            return hasFocus() ? length : Math.ceil(length / options.perPage);
                        },
                        /**
     * Return the edge index.
     *
     * @return {number} - Edge index.
     */ get edgeIndex () {
                            var length1 = Splide.length;
                            if (!length1) {
                                return 0;
                            }
                            if (hasFocus() || options.isNavigation || isLoop) {
                                return length1 - 1;
                            }
                            return length1 - options.perPage;
                        },
                        /**
     * Return the index of the previous slide.
     *
     * @return {number} - The index of the previous slide if available. -1 otherwise.
     */ get prevIndex () {
                            var prev = Splide.index - 1;
                            if (isLoop || options.rewind) {
                                prev = this.rewind(prev);
                            }
                            return prev > -1 ? prev : -1;
                        },
                        /**
     * Return the index of the next slide.
     *
     * @return {number} - The index of the next slide if available. -1 otherwise.
     */ get nextIndex () {
                            var next = Splide.index + 1;
                            if (isLoop || options.rewind) {
                                next = this.rewind(next);
                            }
                            return Splide.index < next && next <= this.edgeIndex || next === 0 ? next : -1;
                        }
                    };
                    /**
   * Listen to some events.
   */ function bind() {
                        Splide.on('move', function(newIndex) {
                            Splide.index = newIndex;
                        }).on('updated refresh', function(newOptions) {
                            options = newOptions || options;
                            Splide.index = between(Splide.index, 0, Controller.edgeIndex);
                        });
                    }
                    /**
   * Verify if the focus option is available or not.
   *
   * @return {boolean} - True if a slider has the focus option.
   */ function hasFocus() {
                        return options.focus !== false;
                    }
                    /**
   * Return the next or previous page index computed by the page number and current index.
   *
   * @param {number}  number - Specify the page number.
   * @param {number}  index  - Current index.
   * @param {boolean} prev   - Prev or next.
   *
   * @return {number} - Slide index.
   */ function parsePage(number, index, prev) {
                        if (number > -1) {
                            return Controller.toIndex(number);
                        }
                        var perMove = options.perMove;
                        var sign = prev ? -1 : 1;
                        if (perMove) {
                            return index + perMove * sign;
                        }
                        return Controller.toIndex(Controller.toPage(index) + sign);
                    }
                    return Controller;
                };
                ; // CONCATENATED MODULE: ./src/js/components/track/index.js
                /**
 * The component for moving list in the track.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ var abs = Math.abs;
                /**
 * The component for moving list in the track.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const track = function(Splide, Components) {
                    /**
   * Hold the Layout component.
   *
   * @type {Object}
   */ var Layout;
                    /**
   * Hold the Layout component.
   *
   * @type {Object}
   */ var Elements;
                    /**
   * Store the list element.
   *
   * @type {Element}
   */ var list;
                    /**
   * Whether the current direction is vertical or not.
   *
   * @type {boolean}
   */ var isVertical = Splide.options.direction === TTB;
                    /**
   * Whether the slider type is FADE or not.
   *
   * @type {boolean}
   */ var isFade = Splide.is(FADE);
                    /**
   * Whether the slider direction is RTL or not.
   *
   * @type {boolean}
   */ var isRTL = Splide.options.direction === RTL;
                    /**
   * This will be true while transitioning from the last index to the first one.
   *
   * @type {boolean}
   */ var isLoopPending = false;
                    /**
   * Sign for the direction. Only RTL mode uses the positive sign.
   *
   * @type {number}
   */ var sign = isRTL ? 1 : -1;
                    /**
   * Track component object.
   *
   * @type {Object}
   */ var Track = {
                        /**
     * Make public the sign defined locally.
     *
     * @type {number}
     */ sign: sign,
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            Elements = Components.Elements;
                            Layout = Components.Layout;
                            list = Elements.list;
                        },
                        /**
     * Called after the component is mounted.
     * The resize event must be registered after the Layout's one is done.
     */ mounted: function mounted() {
                            var _this = this;
                            if (!isFade) {
                                this.jump(0);
                                Splide.on('mounted resize updated', function() {
                                    _this.jump(Splide.index);
                                });
                            }
                        },
                        /**
     * Go to the given destination index.
     * After arriving there, the track is jump to the new index without animation, mainly for loop mode.
     *
     * @param {number}  destIndex - A destination index.
     *                              This can be negative or greater than slides length for reaching clones.
     * @param {number}  newIndex  - An actual new index. They are always same in Slide and Rewind mode.
     * @param {boolean} silently  - If true, suppress emitting events.
     */ go: function go(destIndex, newIndex, silently) {
                            var newPosition = getTrimmedPosition(destIndex);
                            var prevIndex = Splide.index; // Prevent any actions while transitioning from the last index to the first one for jump.
                            if (Splide.State.is(MOVING) && isLoopPending) {
                                return;
                            }
                            isLoopPending = destIndex !== newIndex;
                            if (!silently) {
                                Splide.emit('move', newIndex, prevIndex, destIndex);
                            }
                            if (Math.abs(newPosition - this.position) >= 1 || isFade) {
                                Components.Transition.start(destIndex, newIndex, prevIndex, this.toCoord(newPosition), function() {
                                    onTransitionEnd(destIndex, newIndex, prevIndex, silently);
                                });
                            } else {
                                if (destIndex !== prevIndex && Splide.options.trimSpace === 'move') {
                                    Components.Controller.go(destIndex + destIndex - prevIndex, silently);
                                } else {
                                    onTransitionEnd(destIndex, newIndex, prevIndex, silently);
                                }
                            }
                        },
                        /**
     * Move the track to the specified index.
     *
     * @param {number} index - A destination index where the track jumps.
     */ jump: function jump(index) {
                            this.translate(getTrimmedPosition(index));
                        },
                        /**
     * Set the list position by CSS translate property.
     *
     * @param {number} position - A new position value.
     */ translate: function translate(position) {
                            applyStyle(list, {
                                transform: "translate" + (isVertical ? 'Y' : 'X') + "(" + position + "px)"
                            });
                        },
                        /**
     * Cancel the transition and set the list position.
     * Also, loop the slider if necessary.
     */ cancel: function cancel() {
                            if (Splide.is(LOOP)) {
                                this.shift();
                            } else {
                                // Ensure the current position.
                                this.translate(this.position);
                            }
                            applyStyle(list, {
                                transition: ''
                            });
                        },
                        /**
     * Shift the slider if it exceeds borders on the edge.
     */ shift: function shift() {
                            var position = abs(this.position);
                            var left = abs(this.toPosition(0));
                            var right = abs(this.toPosition(Splide.length));
                            var innerSize = right - left;
                            if (position < left) {
                                position += innerSize;
                            } else if (position > right) {
                                position -= innerSize;
                            }
                            this.translate(sign * position);
                        },
                        /**
     * Trim redundant spaces on the left or right edge if necessary.
     *
     * @param {number} position - Position value to be trimmed.
     *
     * @return {number} - Trimmed position.
     */ trim: function trim(position) {
                            if (!Splide.options.trimSpace || Splide.is(LOOP)) {
                                return position;
                            }
                            var edge = sign * (Layout.totalSize() - Layout.size - Layout.gap);
                            return between(position, edge, 0);
                        },
                        /**
     * Calculate the closest slide index from the given position.
     *
     * @param {number} position - A position converted to an slide index.
     *
     * @return {number} - The closest slide index.
     */ toIndex: function toIndex(position) {
                            var _this2 = this;
                            var index = 0;
                            var minDistance = Infinity;
                            Elements.getSlides(true).forEach(function(Slide) {
                                var slideIndex = Slide.index;
                                var distance = abs(_this2.toPosition(slideIndex) - position);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    index = slideIndex;
                                }
                            });
                            return index;
                        },
                        /**
     * Return coordinates object by the given position.
     *
     * @param {number} position - A position value.
     *
     * @return {Object} - A coordinates object.
     */ toCoord: function toCoord(position) {
                            return {
                                x: isVertical ? 0 : position,
                                y: isVertical ? position : 0
                            };
                        },
                        /**
     * Calculate the track position by a slide index.
     *
     * @param {number} index - Slide index.
     *
     * @return {Object} - Calculated position.
     */ toPosition: function toPosition(index) {
                            var position = Layout.totalSize(index) - Layout.slideSize(index) - Layout.gap;
                            return sign * (position + this.offset(index));
                        },
                        /**
     * Return the current offset value, considering direction.
     *
     * @return {number} - Offset amount.
     */ offset: function offset(index) {
                            var focus = Splide.options.focus;
                            var slideSize = Layout.slideSize(index);
                            if (focus === 'center') {
                                return -(Layout.size - slideSize) / 2;
                            }
                            return -(parseInt(focus) || 0) * (slideSize + Layout.gap);
                        },
                        /**
     * Return the current position.
     * This returns the correct position even while transitioning by CSS.
     *
     * @return {number} - Current position.
     */ get position () {
                            var prop = isVertical ? 'top' : isRTL ? 'right' : 'left';
                            return getRect(list)[prop] - (getRect(Elements.track)[prop] - Layout.padding[prop] * sign);
                        }
                    };
                    /**
   * Called whenever slides arrive at a destination.
   *
   * @param {number}  destIndex - A destination index.
   * @param {number}  newIndex  - A new index.
   * @param {number}  prevIndex - A previous index.
   * @param {boolean} silently  - If true, suppress emitting events.
   */ function onTransitionEnd(destIndex, newIndex, prevIndex, silently) {
                        applyStyle(list, {
                            transition: ''
                        });
                        isLoopPending = false;
                        if (!isFade) {
                            Track.jump(newIndex);
                        }
                        if (!silently) {
                            Splide.emit('moved', newIndex, prevIndex, destIndex);
                        }
                    }
                    /**
   * Convert index to the trimmed position.
   *
   * @return {number} - Trimmed position.
   */ function getTrimmedPosition(index) {
                        return Track.trim(Track.toPosition(index));
                    }
                    return Track;
                };
                ; // CONCATENATED MODULE: ./src/js/components/clones/index.js
                /**
 * The component for cloning some slides for "loop" mode of the track.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The component for cloning some slides for "loop" mode of the track.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const clones = function(Splide, Components) {
                    /**
   * Store information of all clones.
   *
   * @type {Array}
   */ var clones = [];
                    /**
   * Store the current clone count on one side.
   *
   * @type {number}
   */ var cloneCount = 0;
                    /**
   * Keep Elements component.
   *
   * @type {Object}
   */ var Elements = Components.Elements;
                    /**
   * Clones component object.
   *
   * @type {Object}
   */ var Clones = {
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            var _this = this;
                            if (Splide.is(LOOP)) {
                                init();
                                Splide.on('refresh:before', function() {
                                    _this.destroy();
                                }).on('refresh', init).on('resize', function() {
                                    if (cloneCount !== getCloneCount()) {
                                        // Destroy before refresh not to collect clones by the Elements component.
                                        _this.destroy();
                                        Splide.refresh();
                                    }
                                });
                            }
                        },
                        /**
     * Destroy.
     */ destroy: function destroy() {
                            dom_remove(clones);
                            clones = [];
                        },
                        /**
     * Return all clones.
     *
     * @return {Element[]} - Cloned elements.
     */ get clones () {
                            return clones;
                        },
                        /**
     * Return clone length.
     *
     * @return {number} - A length of clones.
     */ get length () {
                            return clones.length;
                        }
                    };
                    /**
   * Initialization.
   */ function init() {
                        Clones.destroy();
                        cloneCount = getCloneCount();
                        generateClones(cloneCount);
                    }
                    /**
   * Generate and append/prepend clones.
   *
   * @param {number} count - The half number of clones.
   */ function generateClones(count) {
                        var length = Elements.length, register = Elements.register;
                        if (length) {
                            var slides = Elements.slides;
                            while(slides.length < count){
                                slides = slides.concat(slides);
                            } // Clones after the last element.
                            slides.slice(0, count).forEach(function(elm, index) {
                                var clone = cloneDeeply(elm);
                                append(Elements.list, clone);
                                clones.push(clone);
                                register(clone, index + length, index % length);
                            }); // Clones before the first element.
                            slides.slice(-count).forEach(function(elm, index) {
                                var clone = cloneDeeply(elm);
                                before(clone, slides[0]);
                                clones.push(clone);
                                register(clone, index - count, (length + index - count % length) % length);
                            });
                        }
                    }
                    /**
   * Return half count of clones to be generated.
   * Clone count is determined by:
   * - "clones" value in the options.
   * - Number of slides that can be placed in a view in "fixed" mode.
   * - Max pages a flick action can move.
   * - Whether the slide length is enough for perPage.
   *
   * @return {number} - Count for clones.
   */ function getCloneCount() {
                        var options = Splide.options;
                        if (options.clones) {
                            return options.clones;
                        } // Use the slide length in autoWidth mode because the number cannot be calculated.
                        var baseCount = options.autoWidth || options.autoHeight ? Elements.length : options.perPage;
                        var dimension = options.direction === TTB ? 'Height' : 'Width';
                        var fixedSize = toPixel(Splide.root, options["fixed" + dimension]);
                        if (fixedSize) {
                            // Roughly calculate the count. This needs not to be strict.
                            baseCount = Math.ceil(Elements.track["client" + dimension] / fixedSize);
                        }
                        return baseCount * (options.drag ? options.flickMaxPages + 1 : 1);
                    }
                    /**
   * Clone deeply the given element.
   *
   * @param {Element} elm - An element being duplicated.
   *
   * @return {Node} - A cloned node(element).
   */ function cloneDeeply(elm) {
                        var clone = elm.cloneNode(true);
                        addClass(clone, Splide.classes.clone); // ID should not be duplicated.
                        removeAttribute(clone, 'id');
                        return clone;
                    }
                    return Clones;
                };
                ; // CONCATENATED MODULE: ./src/js/components/layout/directions/horizontal.js
                /**
 * The resolver component for horizontal layout.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The resolver component for horizontal layout.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 *
 * @return {Object} - The resolver object.
 */ /* harmony default export */ const horizontal = function(Splide, Components) {
                    /**
   * Keep the Elements component.
   *
   * @type {string}
   */ var Elements = Components.Elements;
                    /**
   * Keep the root element.
   *
   * @type {Element}
   */ var root = Splide.root;
                    /**
   * Keep the track element.
   *
   * @type {Element}
   */ var track;
                    /**
   * Keep the latest options.
   *
   * @type {Element}
   */ var options = Splide.options;
                    return {
                        /**
     * Margin property name.
     *
     * @type {string}
     */ margin: 'margin' + (options.direction === RTL ? 'Left' : 'Right'),
                        /**
     * Always 0 because the height will be determined by inner contents.
     *
     * @type {number}
     */ height: 0,
                        /**
     * Initialization.
     */ init: function init() {
                            this.resize();
                        },
                        /**
     * Resize gap and padding.
     * This must be called on init.
     */ resize: function resize() {
                            options = Splide.options;
                            track = Elements.track;
                            this.gap = toPixel(root, options.gap);
                            var padding = options.padding;
                            var left = toPixel(root, padding.left || padding);
                            var right = toPixel(root, padding.right || padding);
                            this.padding = {
                                left: left,
                                right: right
                            };
                            applyStyle(track, {
                                paddingLeft: unit(left),
                                paddingRight: unit(right)
                            });
                        },
                        /**
     * Return total width from the left of the list to the right of the slide specified by the provided index.
     *
     * @param {number} index - Optional. A slide index. If undefined, total width of the slider will be returned.
     *
     * @return {number} - Total width to the right side of the specified slide, or 0 for an invalid index.
     */ totalWidth: function totalWidth(index) {
                            if (index === void 0) {
                                index = Splide.length - 1;
                            }
                            var Slide = Elements.getSlide(index);
                            var width = 0;
                            if (Slide) {
                                var slideRect = getRect(Slide.slide);
                                var listRect = getRect(Elements.list);
                                if (options.direction === RTL) {
                                    width = listRect.right - slideRect.left;
                                } else {
                                    width = slideRect.right - listRect.left;
                                }
                                width += this.gap;
                            }
                            return width;
                        },
                        /**
     * Return the slide width in px.
     *
     * @param {number} index - Slide index.
     *
     * @return {number} - The slide width.
     */ slideWidth: function slideWidth(index) {
                            if (options.autoWidth) {
                                var Slide = Elements.getSlide(index);
                                return Slide ? Slide.slide.offsetWidth : 0;
                            }
                            var width = options.fixedWidth || (this.width + this.gap) / options.perPage - this.gap;
                            return toPixel(root, width);
                        },
                        /**
     * Return the slide height in px.
     *
     * @return {number} - The slide height.
     */ slideHeight: function slideHeight() {
                            var height = options.height || options.fixedHeight || this.width * options.heightRatio;
                            return toPixel(root, height);
                        },
                        /**
     * Return slider width without padding.
     *
     * @return {number} - Current slider width.
     */ get width () {
                            return track.clientWidth - this.padding.left - this.padding.right;
                        }
                    };
                };
                ; // CONCATENATED MODULE: ./src/js/components/layout/directions/vertical.js
                /**
 * The resolver component for vertical layout.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The resolver component for vertical layout.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 *
 * @return {Object} - The resolver object.
 */ /* harmony default export */ const vertical = function(Splide, Components) {
                    /**
   * Keep the Elements component.
   *
   * @type {string}
   */ var Elements = Components.Elements;
                    /**
   * Keep the root element.
   *
   * @type {Element}
   */ var root = Splide.root;
                    /**
   * Keep the track element.
   *
   * @type {Element}
   */ var track;
                    /**
   * Keep the latest options.
   *
   * @type {Element}
   */ var options;
                    return {
                        /**
     * Margin property name.
     *
     * @type {string}
     */ margin: 'marginBottom',
                        /**
     * Initialization.
     */ init: function init() {
                            this.resize();
                        },
                        /**
     * Resize gap and padding.
     * This must be called on init.
     */ resize: function resize() {
                            options = Splide.options;
                            track = Elements.track;
                            this.gap = toPixel(root, options.gap);
                            var padding = options.padding;
                            var top = toPixel(root, padding.top || padding);
                            var bottom = toPixel(root, padding.bottom || padding);
                            this.padding = {
                                top: top,
                                bottom: bottom
                            };
                            applyStyle(track, {
                                paddingTop: unit(top),
                                paddingBottom: unit(bottom)
                            });
                        },
                        /**
     * Return total height from the top of the list to the bottom of the slide specified by the provided index.
     *
     * @param {number} index - Optional. A slide index. If undefined, total height of the slider will be returned.
     *
     * @return {number} - Total height to the bottom of the specified slide, or 0 for an invalid index.
     */ totalHeight: function totalHeight(index) {
                            if (index === void 0) {
                                index = Splide.length - 1;
                            }
                            var Slide = Elements.getSlide(index);
                            if (Slide) {
                                return getRect(Slide.slide).bottom - getRect(Elements.list).top + this.gap;
                            }
                            return 0;
                        },
                        /**
     * Return the slide width in px.
     *
     * @return {number} - The slide width.
     */ slideWidth: function slideWidth() {
                            return toPixel(root, options.fixedWidth || this.width);
                        },
                        /**
     * Return the slide height in px.
     *
     * @param {number} index - Slide index.
     *
     * @return {number} - The slide height.
     */ slideHeight: function slideHeight(index) {
                            if (options.autoHeight) {
                                var Slide = Elements.getSlide(index);
                                return Slide ? Slide.slide.offsetHeight : 0;
                            }
                            var height = options.fixedHeight || (this.height + this.gap) / options.perPage - this.gap;
                            return toPixel(root, height);
                        },
                        /**
     * Return slider width without padding.
     *
     * @return {number} - Current slider width.
     */ get width () {
                            return track.clientWidth;
                        },
                        /**
     * Return slide height without padding.
     *
     * @return {number} - Slider height.
     */ get height () {
                            var height = options.height || this.width * options.heightRatio;
                            exist(height, '"height" or "heightRatio" is missing.');
                            return toPixel(root, height) - this.padding.top - this.padding.bottom;
                        }
                    };
                };
                ; // CONCATENATED MODULE: ./src/js/utils/time.js
                /**
 * A package of utility functions related with time.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Simple throttle function that controls how often the given function is executed.
 *
 * @param {function} func - A function to be throttled.
 * @param {number}   wait - Time in millisecond for interval of execution.
 *
 * @return {Function} - A debounced function.
 */ function throttle(func, wait) {
                    var timeout; // Declare function by the "function" keyword to prevent "this" from being inherited.
                    return function() {
                        if (!timeout) {
                            timeout = setTimeout(function() {
                                func();
                                timeout = null;
                            }, wait);
                        }
                    };
                }
                /**
 * Custom setInterval function that provides progress rate as callback.
 *
 * @param {function} callback - A callback function fired every time the interval time passes.
 * @param {number}   interval - Interval duration in milliseconds.
 * @param {function} progress - A callback function fired whenever the progress goes.
 *
 * @return {Object} - An object containing play() and pause() functions.
 */ function createInterval(callback, interval, progress) {
                    var _window = window, requestAnimationFrame = _window.requestAnimationFrame;
                    var start, elapse, rate, _pause = true;
                    var step = function step(timestamp) {
                        if (!_pause) {
                            if (!start) {
                                start = timestamp;
                                if (rate && rate < 1) {
                                    start -= rate * interval;
                                }
                            }
                            elapse = timestamp - start;
                            rate = elapse / interval;
                            if (elapse >= interval) {
                                start = 0;
                                rate = 1;
                                callback();
                            }
                            if (progress) {
                                progress(rate);
                            }
                            requestAnimationFrame(step);
                        }
                    };
                    return {
                        pause: function pause() {
                            _pause = true;
                            start = 0;
                        },
                        play: function play(reset) {
                            start = 0;
                            if (reset) {
                                rate = 0;
                            }
                            if (_pause) {
                                _pause = false;
                                requestAnimationFrame(step);
                            }
                        }
                    };
                }
                ; // CONCATENATED MODULE: ./src/js/components/layout/index.js
                /**
 * The component for handing slide layouts and their sizes.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The component for handing slide layouts and their sizes.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const layout = function(Splide, Components) {
                    /**
   * Keep the Elements component.
   *
   * @type {string}
   */ var Elements = Components.Elements;
                    /**
   * Whether the slider is vertical or not.
   *
   * @type {boolean}
   */ var isVertical = Splide.options.direction === TTB;
                    /**
   * Layout component object.
   *
   * @type {Object}
   */ var Layout = object_assign({
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            bind();
                            init(); // The word "size" means width for a horizontal slider and height for a vertical slider.
                            this.totalSize = isVertical ? this.totalHeight : this.totalWidth;
                            this.slideSize = isVertical ? this.slideHeight : this.slideWidth;
                        },
                        /**
     * Destroy the component.
     */ destroy: function destroy() {
                            removeAttribute([
                                Elements.list,
                                Elements.track
                            ], 'style');
                        },
                        /**
     * Return the slider height on the vertical mode or width on the horizontal mode.
     *
     * @return {number}
     */ get size () {
                            return isVertical ? this.height : this.width;
                        }
                    }, isVertical ? vertical(Splide, Components) : horizontal(Splide, Components));
                    /**
   * Init slider styles according to options.
   */ function init() {
                        Layout.init();
                        applyStyle(Splide.root, {
                            maxWidth: unit(Splide.options.width)
                        });
                        Elements.each(function(Slide) {
                            Slide.slide.style[Layout.margin] = unit(Layout.gap);
                        });
                        resize();
                    }
                    /**
   * Listen the resize native event with throttle.
   * Initialize when the component is mounted or options are updated.
   */ function bind() {
                        Splide.on('resize load', throttle(function() {
                            Splide.emit('resize');
                        }, Splide.options.throttle), window).on('resize', resize).on('updated refresh', init);
                    }
                    /**
   * Resize the track and slide elements.
   */ function resize() {
                        var options = Splide.options;
                        Layout.resize();
                        applyStyle(Elements.track, {
                            height: unit(Layout.height)
                        });
                        var slideHeight = options.autoHeight ? null : unit(Layout.slideHeight());
                        Elements.each(function(Slide) {
                            applyStyle(Slide.container, {
                                height: slideHeight
                            });
                            applyStyle(Slide.slide, {
                                width: options.autoWidth ? null : unit(Layout.slideWidth(Slide.index)),
                                height: Slide.container ? null : slideHeight
                            });
                        });
                        Splide.emit('resized');
                    }
                    return Layout;
                };
                ; // CONCATENATED MODULE: ./src/js/components/drag/index.js
                /**
 * The component for supporting mouse drag and swipe.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ var drag_abs = Math.abs;
                /**
 * If the absolute velocity is greater thant this value,
 * a slider always goes to a different slide after drag, not allowed to stay on a current slide.
 */ var MIN_VELOCITY = 0.1;
                /**
 * Adjust how much the track can be pulled on the first or last page.
 * The larger number this is, the farther the track moves.
 * This should be around 5 - 9.
 *
 * @type {number}
 */ var FRICTION_REDUCER = 7;
                /**
 * The component supporting mouse drag and swipe.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const drag = function(Splide, Components) {
                    /**
   * Store the Move component.
   *
   * @type {Object}
   */ var Track = Components.Track;
                    /**
   * Store the Controller component.
   *
   * @type {Object}
   */ var Controller = Components.Controller;
                    /**
   * Coordinate of the track on starting drag.
   *
   * @type {Object}
   */ var startCoord;
                    /**
   * Analyzed info on starting drag.
   *
   * @type {Object|null}
   */ var startInfo;
                    /**
   * Analyzed info being updated while dragging/swiping.
   *
   * @type {Object}
   */ var currentInfo;
                    /**
   * Determine whether slides are being dragged or not.
   *
   * @type {boolean}
   */ var isDragging;
                    /**
   * Whether the slider direction is vertical or not.
   *
   * @type {boolean}
   */ var isVertical = Splide.options.direction === TTB;
                    /**
   * Axis for the direction.
   *
   * @type {string}
   */ var axis = isVertical ? 'y' : 'x';
                    /**
   * Drag component object.
   *
   * @type {Object}
   */ var Drag = {
                        /**
     * Whether dragging is disabled or not.
     *
     * @type {boolean}
     */ disabled: false,
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            var _this = this;
                            var Elements = Components.Elements;
                            var track = Elements.track;
                            Splide.on('touchstart mousedown', start, track).on('touchmove mousemove', move, track, {
                                passive: false
                            }).on('touchend touchcancel mouseleave mouseup dragend', end, track).on('mounted refresh', function() {
                                // Prevent dragging an image or anchor itself.
                                each(Elements.list.querySelectorAll('img, a'), function(elm) {
                                    Splide.off('dragstart', elm).on('dragstart', function(e) {
                                        e.preventDefault();
                                    }, elm, {
                                        passive: false
                                    });
                                });
                            }).on('mounted updated', function() {
                                _this.disabled = !Splide.options.drag;
                            });
                        }
                    };
                    /**
   * Called when the track starts to be dragged.
   *
   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.
   */ function start(e) {
                        if (!Drag.disabled && !isDragging) {
                            // These prams are used to evaluate whether the slider should start moving.
                            init(e);
                        }
                    }
                    /**
   * Initialize parameters.
   *
   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.
   */ function init(e) {
                        startCoord = Track.toCoord(Track.position);
                        startInfo = analyze(e, {});
                        currentInfo = startInfo;
                    }
                    /**
   * Called while the track being dragged.
   *
   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.
   */ function move(e) {
                        if (startInfo) {
                            currentInfo = analyze(e, startInfo);
                            if (isDragging) {
                                if (e.cancelable) {
                                    e.preventDefault();
                                }
                                if (!Splide.is(FADE)) {
                                    var position = startCoord[axis] + currentInfo.offset[axis];
                                    Track.translate(resist(position));
                                }
                            } else {
                                if (shouldMove(currentInfo)) {
                                    Splide.emit('drag', startInfo);
                                    isDragging = true;
                                    Track.cancel(); // These params are actual drag data.
                                    init(e);
                                }
                            }
                        }
                    }
                    /**
   * Determine whether to start moving the track or not by drag angle.
   *
   * @param {Object} info - An information object.
   *
   * @return {boolean} - True if the track should be moved or false if not.
   */ function shouldMove(_ref) {
                        var offset = _ref.offset;
                        if (Splide.State.is(MOVING) && Splide.options.waitForTransition) {
                            return false;
                        }
                        var angle = Math.atan(drag_abs(offset.y) / drag_abs(offset.x)) * 180 / Math.PI;
                        if (isVertical) {
                            angle = 90 - angle;
                        }
                        return angle < Splide.options.dragAngleThreshold;
                    }
                    /**
   * Resist dragging the track on the first/last page because there is no more.
   *
   * @param {number} position - A position being applied to the track.
   *
   * @return {Object} - Adjusted position.
   */ function resist(position) {
                        if (Splide.is(SLIDE)) {
                            var sign = Track.sign;
                            var _start = sign * Track.trim(Track.toPosition(0));
                            var _end = sign * Track.trim(Track.toPosition(Controller.edgeIndex));
                            position *= sign;
                            if (position < _start) {
                                position = _start - FRICTION_REDUCER * Math.log(_start - position);
                            } else if (position > _end) {
                                position = _end + FRICTION_REDUCER * Math.log(position - _end);
                            }
                            position *= sign;
                        }
                        return position;
                    }
                    /**
   * Called when dragging ends.
   */ function end() {
                        startInfo = null;
                        if (isDragging) {
                            Splide.emit('dragged', currentInfo);
                            go(currentInfo);
                            isDragging = false;
                        }
                    }
                    /**
   * Go to the slide determined by the analyzed data.
   *
   * @param {Object} info - An info object.
   */ function go(info) {
                        var velocity = info.velocity[axis];
                        var absV = drag_abs(velocity);
                        if (absV > 0) {
                            var options = Splide.options;
                            var index = Splide.index;
                            var sign = velocity < 0 ? -1 : 1;
                            var destIndex = index;
                            if (!Splide.is(FADE)) {
                                var destination = Track.position;
                                if (absV > options.flickVelocityThreshold && drag_abs(info.offset[axis]) < options.swipeDistanceThreshold) {
                                    destination += sign * Math.min(absV * options.flickPower, Components.Layout.size * (options.flickMaxPages || 1));
                                }
                                destIndex = Track.toIndex(destination);
                            }
                            /*
       * Do not allow the track to go to a previous position if there is enough velocity.
       * Always use the adjacent index for the fade mode.
       */ if (destIndex === index && absV > MIN_VELOCITY) {
                                destIndex = index + sign * Track.sign;
                            }
                            if (Splide.is(SLIDE)) {
                                destIndex = between(destIndex, 0, Controller.edgeIndex);
                            }
                            Controller.go(destIndex, options.isNavigation);
                        }
                    }
                    /**
   * Analyze the given event object and return important information for handling swipe behavior.
   *
   * @param {Event}   e          - Touch or Mouse event object.
   * @param {Object}  startInfo  - Information analyzed on start for calculating difference from the current one.
   *
   * @return {Object} - An object containing analyzed information, such as offset, velocity, etc.
   */ function analyze(e, startInfo) {
                        var timeStamp = e.timeStamp, touches = e.touches;
                        var _ref2 = touches ? touches[0] : e, clientX = _ref2.clientX, clientY = _ref2.clientY;
                        var _ref3 = startInfo.to || {}, _ref3$x = _ref3.x, fromX = _ref3$x === void 0 ? clientX : _ref3$x, _ref3$y = _ref3.y, fromY = _ref3$y === void 0 ? clientY : _ref3$y;
                        var startTime = startInfo.time || 0;
                        var offset = {
                            x: clientX - fromX,
                            y: clientY - fromY
                        };
                        var duration = timeStamp - startTime;
                        var velocity = {
                            x: offset.x / duration,
                            y: offset.y / duration
                        };
                        return {
                            to: {
                                x: clientX,
                                y: clientY
                            },
                            offset: offset,
                            time: timeStamp,
                            velocity: velocity
                        };
                    }
                    return Drag;
                };
                ; // CONCATENATED MODULE: ./src/js/components/click/index.js
                /**
 * The component for handling a click event.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The component for handling a click event.
 * Click should be disabled during drag/swipe.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const click = function(Splide, Components) {
                    /**
   * Whether click is disabled or not.
   *
   * @type {boolean}
   */ var disabled = false;
                    /**
   * Click component object.
   *
   * @type {Object}
   */ var Click = {
                        /**
     * Mount only when the drag is activated and the slide type is not "fade".
     *
     * @type {boolean}
     */ required: Splide.options.drag,
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            Splide.on('click', onClick, Components.Elements.track, {
                                capture: true
                            }).on('drag', function() {
                                disabled = true;
                            }).on('dragged', function() {
                                // Make sure the flag is released after the click event is fired.
                                setTimeout(function() {
                                    disabled = false;
                                });
                            });
                        }
                    };
                    /**
   * Called when a track element is clicked.
   *
   * @param {Event} e - A click event.
   */ function onClick(e) {
                        if (disabled) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                        }
                    }
                    return Click;
                };
                ; // CONCATENATED MODULE: ./src/js/components/autoplay/index.js
                /**
 * The component for playing slides automatically.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Set of pause flags.
 */ var PAUSE_FLAGS = {
                    HOVER: 1,
                    FOCUS: 2,
                    MANUAL: 3
                };
                /**
 * The component for playing slides automatically.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 * @param {string} name       - A component name as a lowercase string.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const autoplay = function(Splide, Components, name) {
                    /**
   * Store pause flags.
   *
   * @type {Array}
   */ var flags = [];
                    /**
   * Store an interval object.
   *
   * @type {Object};
   */ var interval;
                    /**
   * Keep the Elements component.
   *
   * @type {string}
   */ var Elements = Components.Elements;
                    /**
   * Autoplay component object.
   *
   * @type {Object}
   */ var Autoplay = {
                        /**
     * Required only when the autoplay option is true.
     *
     * @type {boolean}
     */ required: Splide.options.autoplay,
                        /**
     * Called when the component is mounted.
     * Note that autoplay starts only if there are slides over perPage number.
     */ mount: function mount() {
                            var options = Splide.options;
                            if (Elements.slides.length > options.perPage) {
                                interval = createInterval(function() {
                                    Splide.go('>');
                                }, options.interval, function(rate) {
                                    Splide.emit(name + ":playing", rate);
                                    if (Elements.bar) {
                                        applyStyle(Elements.bar, {
                                            width: rate * 100 + "%"
                                        });
                                    }
                                });
                                bind();
                                this.play();
                            }
                        },
                        /**
     * Start autoplay.
     *
     * @param {number} flag - A pause flag to be removed.
     */ play: function play(flag) {
                            if (flag === void 0) {
                                flag = 0;
                            }
                            flags = flags.filter(function(f) {
                                return f !== flag;
                            });
                            if (!flags.length) {
                                Splide.emit(name + ":play");
                                interval.play(Splide.options.resetProgress);
                            }
                        },
                        /**
     * Pause autoplay.
     * Note that Array.includes is not supported by IE.
     *
     * @param {number} flag - A pause flag to be added.
     */ pause: function pause(flag) {
                            if (flag === void 0) {
                                flag = 0;
                            }
                            interval.pause();
                            if (flags.indexOf(flag) === -1) {
                                flags.push(flag);
                            }
                            if (flags.length === 1) {
                                Splide.emit(name + ":pause");
                            }
                        }
                    };
                    /**
   * Listen some events.
   */ function bind() {
                        var options = Splide.options;
                        var sibling = Splide.sibling;
                        var elms = [
                            Splide.root,
                            sibling ? sibling.root : null
                        ];
                        if (options.pauseOnHover) {
                            switchOn(elms, 'mouseleave', PAUSE_FLAGS.HOVER, true);
                            switchOn(elms, 'mouseenter', PAUSE_FLAGS.HOVER, false);
                        }
                        if (options.pauseOnFocus) {
                            switchOn(elms, 'focusout', PAUSE_FLAGS.FOCUS, true);
                            switchOn(elms, 'focusin', PAUSE_FLAGS.FOCUS, false);
                        }
                        if (Elements.play) {
                            Splide.on('click', function() {
                                // Need to be removed a focus flag at first.
                                Autoplay.play(PAUSE_FLAGS.FOCUS);
                                Autoplay.play(PAUSE_FLAGS.MANUAL);
                            }, Elements.play);
                        }
                        if (Elements.pause) {
                            switchOn([
                                Elements.pause
                            ], 'click', PAUSE_FLAGS.MANUAL, false);
                        }
                        Splide.on('move refresh', function() {
                            Autoplay.play();
                        }) // Rewind the timer.
                        .on('destroy', function() {
                            Autoplay.pause();
                        });
                    }
                    /**
   * Play or pause on the given event.
   *
   * @param {Element[]} elms  - Elements.
   * @param {string}    event - An event name or names.
   * @param {number}    flag  - A pause flag defined on the top.
   * @param {boolean}   play  - Determine whether to play or pause.
   */ function switchOn(elms, event, flag, play) {
                        elms.forEach(function(elm) {
                            Splide.on(event, function() {
                                Autoplay[play ? 'play' : 'pause'](flag);
                            }, elm);
                        });
                    }
                    return Autoplay;
                };
                ; // CONCATENATED MODULE: ./src/js/components/cover/index.js
                /**
 * The component for change an img element to background image of its wrapper.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The component for change an img element to background image of its wrapper.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const cover = function(Splide, Components) {
                    /**
   * Hold options.
   *
   * @type {Object}
   */ var options = Splide.options;
                    /**
   * Cover component object.
   *
   * @type {Object}
   */ var Cover = {
                        /**
     * Required only when "cover" option is true.
     *
     * @type {boolean}
     */ required: options.cover,
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            Splide.on('lazyload:loaded', function(img) {
                                cover(img, false);
                            });
                            Splide.on('mounted updated refresh', function() {
                                return apply(false);
                            });
                        },
                        /**
     * Destroy.
     */ destroy: function destroy() {
                            apply(true);
                        }
                    };
                    /**
   * Apply "cover" to all slides.
   *
   * @param {boolean} uncover - If true, "cover" will be clear.
   */ function apply(uncover) {
                        Components.Elements.each(function(Slide) {
                            var img = child(Slide.slide, 'IMG') || child(Slide.container, 'IMG');
                            if (img && img.src) {
                                cover(img, uncover);
                            }
                        });
                    }
                    /**
   * Set background image of the parent element, using source of the given image element.
   *
   * @param {Element} img     - An image element.
   * @param {boolean} uncover - Reset "cover".
   */ function cover(img, uncover) {
                        applyStyle(img.parentElement, {
                            background: uncover ? '' : "center/cover no-repeat url(\"" + img.src + "\")"
                        });
                        applyStyle(img, {
                            display: uncover ? '' : 'none'
                        });
                    }
                    return Cover;
                };
                ; // CONCATENATED MODULE: ./src/js/components/arrows/path.js
                /**
 * Export vector path for an arrow.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Namespace definition for SVG element.
 *
 * @type {string}
 */ var XML_NAME_SPACE = 'http://www.w3.org/2000/svg';
                /**
 * The arrow vector path.
 *
 * @type {number}
 */ var PATH = 'm15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z';
                /**
 * SVG width and height.
 *
 * @type {number}
 */ var SIZE = 40;
                ; // CONCATENATED MODULE: ./src/js/components/arrows/index.js
                /**
 * The component for appending prev/next arrows.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The component for appending prev/next arrows.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 * @param {string} name       - A component name as a lowercase string.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const arrows = function(Splide, Components, name) {
                    /**
   * Previous arrow element.
   *
   * @type {Element|undefined}
   */ var prev;
                    /**
   * Next arrow element.
   *
   * @type {Element|undefined}
   */ var next;
                    /**
   * Store the class list.
   *
   * @type {Object}
   */ var classes = Splide.classes;
                    /**
   * Hold the root element.
   *
   * @type {Element}
   */ var root = Splide.root;
                    /**
   * Whether arrows are created programmatically or not.
   *
   * @type {boolean}
   */ var created;
                    /**
   * Hold the Elements component.
   *
   * @type {Object}
   */ var Elements = Components.Elements;
                    /**
   * Arrows component object.
   *
   * @type {Object}
   */ var Arrows = {
                        /**
     * Required when the arrows option is true.
     *
     * @type {boolean}
     */ required: Splide.options.arrows,
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            // Attempt to get arrows from HTML source.
                            prev = Elements.arrows.prev;
                            next = Elements.arrows.next; // If arrows were not found in HTML, let's generate them.
                            if ((!prev || !next) && Splide.options.arrows) {
                                prev = createArrow(true);
                                next = createArrow(false);
                                created = true;
                                appendArrows();
                            }
                            if (prev && next) {
                                bind();
                            }
                            this.arrows = {
                                prev: prev,
                                next: next
                            };
                        },
                        /**
     * Called after all components are mounted.
     */ mounted: function mounted() {
                            Splide.emit(name + ":mounted", prev, next);
                        },
                        /**
     * Destroy.
     */ destroy: function destroy() {
                            removeAttribute([
                                prev,
                                next
                            ], 'disabled');
                            if (created) {
                                dom_remove(prev.parentElement);
                            }
                        }
                    };
                    /**
   * Listen to native and custom events.
   */ function bind() {
                        Splide.on('click', function() {
                            Splide.go('<');
                        }, prev).on('click', function() {
                            Splide.go('>');
                        }, next).on('mounted move updated refresh', updateDisabled);
                    }
                    /**
   * Update a disabled attribute.
   */ function updateDisabled() {
                        var _Components$Controlle = Components.Controller, prevIndex = _Components$Controlle.prevIndex, nextIndex = _Components$Controlle.nextIndex;
                        var isEnough = Splide.length > Splide.options.perPage || Splide.is(LOOP);
                        prev.disabled = prevIndex < 0 || !isEnough;
                        next.disabled = nextIndex < 0 || !isEnough;
                        Splide.emit(name + ":updated", prev, next, prevIndex, nextIndex);
                    }
                    /**
   * Create a wrapper element and append arrows.
   */ function appendArrows() {
                        var wrapper = create('div', {
                            "class": classes.arrows
                        });
                        append(wrapper, prev);
                        append(wrapper, next);
                        var slider = Elements.slider;
                        var parent = Splide.options.arrows === 'slider' && slider ? slider : root;
                        before(wrapper, parent.firstElementChild);
                    }
                    /**
   * Create an arrow element.
   *
   * @param {boolean} prev - Determine to create a prev arrow or next arrow.
   *
   * @return {Element} - A created arrow element.
   */ function createArrow(prev) {
                        var arrow = "<button class=\"" + classes.arrow + " " + (prev ? classes.prev : classes.next) + "\" type=\"button\">" + ("<svg xmlns=\"" + XML_NAME_SPACE + "\"\tviewBox=\"0 0 " + SIZE + " " + SIZE + "\"\twidth=\"" + SIZE + "\"\theight=\"" + SIZE + "\">") + ("<path d=\"" + (Splide.options.arrowPath || PATH) + "\" />");
                        return domify(arrow);
                    }
                    return Arrows;
                };
                ; // CONCATENATED MODULE: ./src/js/components/pagination/index.js
                /**
 * The component for handling pagination
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The event name for updating some attributes of pagination nodes.
 *
 * @type {string}
 */ var ATTRIBUTES_UPDATE_EVENT = 'move.page';
                /**
 * The event name for recreating pagination.
 *
 * @type {string}
 */ var UPDATE_EVENT = 'updated.page refresh.page';
                /**
 * The component for handling pagination
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 * @param {string} name       - A component name as a lowercase string.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const pagination = function(Splide, Components, name) {
                    /**
   * Store all data for pagination.
   * - list: A list element.
   * - items: An array that contains objects(li, button, index, page).
   *
   * @type {Object}
   */ var data = {};
                    /**
   * Hold the Elements component.
   *
   * @type {Object}
   */ var Elements = Components.Elements;
                    /**
   * Pagination component object.
   *
   * @type {Object}
   */ var Pagination = {
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            var pagination = Splide.options.pagination;
                            if (pagination) {
                                data = createPagination();
                                var slider = Elements.slider;
                                var parent = pagination === 'slider' && slider ? slider : Splide.root;
                                append(parent, data.list);
                                Splide.on(ATTRIBUTES_UPDATE_EVENT, updateAttributes);
                            }
                            Splide.off(UPDATE_EVENT).on(UPDATE_EVENT, function() {
                                Pagination.destroy();
                                if (Splide.options.pagination) {
                                    Pagination.mount();
                                    Pagination.mounted();
                                }
                            });
                        },
                        /**
     * Called after all components are mounted.
     */ mounted: function mounted() {
                            if (Splide.options.pagination) {
                                var index = Splide.index;
                                Splide.emit(name + ":mounted", data, this.getItem(index));
                                updateAttributes(index, -1);
                            }
                        },
                        /**
     * Destroy the pagination.
     * Be aware that node.remove() is not supported by IE.
     */ destroy: function destroy() {
                            dom_remove(data.list);
                            if (data.items) {
                                data.items.forEach(function(item) {
                                    Splide.off('click', item.button);
                                });
                            } // Do not remove UPDATE_EVENT to recreate pagination if needed.
                            Splide.off(ATTRIBUTES_UPDATE_EVENT);
                            data = {};
                        },
                        /**
     * Return an item by index.
     *
     * @param {number} index - A slide index.
     *
     * @return {Object|undefined} - An item object on success or undefined on failure.
     */ getItem: function getItem(index) {
                            return data.items[Components.Controller.toPage(index)];
                        },
                        /**
     * Return object containing pagination data.
     *
     * @return {Object} - Pagination data including list and items.
     */ get data () {
                            return data;
                        }
                    };
                    /**
   * Update attributes.
   *
   * @param {number} index     - Active index.
   * @param {number} prevIndex - Prev index.
   */ function updateAttributes(index, prevIndex) {
                        var prev = Pagination.getItem(prevIndex);
                        var curr = Pagination.getItem(index);
                        var active = STATUS_CLASSES.active;
                        if (prev) {
                            removeClass(prev.button, active);
                        }
                        if (curr) {
                            addClass(curr.button, active);
                        }
                        Splide.emit(name + ":updated", data, prev, curr);
                    }
                    /**
   * Create a wrapper and button elements.
   *
   * @return {Object} - An object contains all data.
   */ function createPagination() {
                        var options = Splide.options;
                        var classes = Splide.classes;
                        var list = create('ul', {
                            "class": classes.pagination
                        });
                        var items = Elements.getSlides(false).filter(function(Slide) {
                            return options.focus !== false || Slide.index % options.perPage === 0;
                        }).map(function(Slide, page) {
                            var li = create('li', {});
                            var button = create('button', {
                                "class": classes.page,
                                type: 'button'
                            });
                            append(li, button);
                            append(list, li);
                            Splide.on('click', function() {
                                Splide.go(">" + page);
                            }, button);
                            return {
                                li: li,
                                button: button,
                                page: page,
                                Slides: Elements.getSlidesByPage(page)
                            };
                        });
                        return {
                            list: list,
                            items: items
                        };
                    }
                    return Pagination;
                };
                ; // CONCATENATED MODULE: ./src/js/components/lazyload/index.js
                /**
 * The component for loading slider images lazily.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The name for a data attribute of src.
 *
 * @type {string}
 */ var SRC_DATA_NAME = 'data-splide-lazy';
                /**
 * The name for a data attribute of srcset.
 *
 * @type {string}
 */ var SRCSET_DATA_NAME = 'data-splide-lazy-srcset';
                /**
 * The component for loading slider images lazily.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 * @param {string} name       - A component name as a lowercase string.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const lazyload = function(Splide, Components, name) {
                    /**
   * Next index for sequential loading.
   *
   * @type {number}
   */ var nextIndex;
                    /**
   * Store objects containing an img element and a Slide object.
   *
   * @type {Object[]}
   */ var images;
                    /**
   * Store the options.
   *
   * @type {Object}
   */ var options = Splide.options;
                    /**
   * Whether to load images sequentially or not.
   *
   * @type {boolean}
   */ var isSequential = options.lazyLoad === 'sequential';
                    /**
   * Lazyload component object.
   *
   * @type {Object}
   */ var Lazyload = {
                        /**
     * Mount only when the lazyload option is provided.
     *
     * @type {boolean}
     */ required: options.lazyLoad,
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            Splide.on('mounted refresh', function() {
                                init();
                                Components.Elements.each(function(Slide) {
                                    each(Slide.slide.querySelectorAll("[" + SRC_DATA_NAME + "], [" + SRCSET_DATA_NAME + "]"), function(img) {
                                        if (!img.src && !img.srcset) {
                                            images.push({
                                                img: img,
                                                Slide: Slide
                                            });
                                            applyStyle(img, {
                                                display: 'none'
                                            });
                                        }
                                    });
                                });
                                if (isSequential) {
                                    loadNext();
                                }
                            });
                            if (!isSequential) {
                                Splide.on("mounted refresh moved." + name, check);
                            }
                        },
                        /**
     * Destroy.
     */ destroy: init
                    };
                    /**
   * Initialize parameters.
   */ function init() {
                        images = [];
                        nextIndex = 0;
                    }
                    /**
   * Check how close each image is from the active slide and
   * determine whether to start loading or not, according to the distance.
   *
   * @param {number} index - Current index.
   */ function check(index) {
                        index = isNaN(index) ? Splide.index : index;
                        images = images.filter(function(image) {
                            if (image.Slide.isWithin(index, options.perPage * (options.preloadPages + 1))) {
                                load(image.img, image.Slide);
                                return false;
                            }
                            return true;
                        }); // Unbind if all images are loaded.
                        if (!images[0]) {
                            Splide.off("moved." + name);
                        }
                    }
                    /**
   * Start loading an image.
   * Creating a clone of the image element since setting src attribute directly to it
   * often occurs 'hitch', blocking some other processes of a browser.
   *
   * @param {Element} img   - An image element.
   * @param {Object}  Slide - A Slide object.
   */ function load(img, Slide) {
                        addClass(Slide.slide, STATUS_CLASSES.loading);
                        var spinner = create('span', {
                            "class": Splide.classes.spinner
                        });
                        append(img.parentElement, spinner);
                        img.onload = function() {
                            loaded(img, spinner, Slide, false);
                        };
                        img.onerror = function() {
                            loaded(img, spinner, Slide, true);
                        };
                        setAttribute(img, 'srcset', getAttribute(img, SRCSET_DATA_NAME) || '');
                        setAttribute(img, 'src', getAttribute(img, SRC_DATA_NAME) || '');
                    }
                    /**
   * Start loading a next image in images array.
   */ function loadNext() {
                        if (nextIndex < images.length) {
                            var image = images[nextIndex];
                            load(image.img, image.Slide);
                        }
                        nextIndex++;
                    }
                    /**
   * Called just after the image was loaded or loading was aborted by some error.
   *
   * @param {Element} img     - An image element.
   * @param {Element} spinner - A spinner element.
   * @param {Object}  Slide   - A Slide object.
   * @param {boolean} error   - True if the image was loaded successfully or false on error.
   */ function loaded(img, spinner, Slide, error) {
                        removeClass(Slide.slide, STATUS_CLASSES.loading);
                        if (!error) {
                            dom_remove(spinner);
                            applyStyle(img, {
                                display: ''
                            });
                            Splide.emit(name + ":loaded", img).emit('resize');
                        }
                        if (isSequential) {
                            loadNext();
                        }
                    }
                    return Lazyload;
                };
                ; // CONCATENATED MODULE: ./src/js/constants/a11y.js
                /**
 * Export aria attribute names.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Attribute name for aria-current.
 *
 * @type {string}
 */ var ARIA_CURRENRT = 'aria-current';
                /**
 * Attribute name for aria-control.
 *
 * @type {string}
 */ var ARIA_CONTROLS = 'aria-controls';
                /**
 * Attribute name for aria-control.
 *
 * @type {string}
 */ var ARIA_LABEL = 'aria-label';
                /**
 * Attribute name for aria-labelledby.
 *
 * @type {string}
 */ var ARIA_LABELLEDBY = 'aria-labelledby';
                /**
 * Attribute name for aria-hidden.
 *
 * @type {string}
 */ var ARIA_HIDDEN = 'aria-hidden';
                /**
 * Attribute name for tab-index.
 *
 * @type {string}
 */ var TAB_INDEX = 'tabindex';
                ; // CONCATENATED MODULE: ./src/js/components/keyboard/index.js
                /**
 * The component for controlling slides via keyboard.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Map a key to a slide control.
 *
 * @type {Object}
 */ var KEY_MAP = {
                    ltr: {
                        ArrowLeft: '<',
                        ArrowRight: '>',
                        // For IE.
                        Left: '<',
                        Right: '>'
                    },
                    rtl: {
                        ArrowLeft: '>',
                        ArrowRight: '<',
                        // For IE.
                        Left: '>',
                        Right: '<'
                    },
                    ttb: {
                        ArrowUp: '<',
                        ArrowDown: '>',
                        // For IE.
                        Up: '<',
                        Down: '>'
                    }
                };
                /**
 * The component for controlling slides via keyboard.
 *
 * @param {Splide} Splide - A Splide instance.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const keyboard = function(Splide) {
                    /**
   * Hold the target element.
   *
   * @type {Element|Document|undefined}
   */ var target;
                    return {
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            Splide.on('mounted updated', function() {
                                var options = Splide.options;
                                var root = Splide.root;
                                var map = KEY_MAP[options.direction];
                                var keyboard = options.keyboard;
                                if (target) {
                                    Splide.off('keydown', target);
                                    removeAttribute(root, TAB_INDEX);
                                }
                                if (keyboard) {
                                    if (keyboard === 'focused') {
                                        target = root;
                                        setAttribute(root, TAB_INDEX, 0);
                                    } else {
                                        target = document;
                                    }
                                    Splide.on('keydown', function(e) {
                                        if (map[e.key]) {
                                            Splide.go(map[e.key]);
                                        }
                                    }, target);
                                }
                            });
                        }
                    };
                };
                ; // CONCATENATED MODULE: ./src/js/components/a11y/index.js
                /**
 * The component for enhancing accessibility.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The component for enhancing accessibility.
 *
 * @param {Splide} Splide     - A Splide instance.
 * @param {Object} Components - An object containing components.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const a11y = function(Splide, Components) {
                    /**
   * Hold a i18n object.
   *
   * @type {Object}
   */ var i18n = Splide.i18n;
                    /**
   * Hold the Elements component.
   *
   * @type {Object}
   */ var Elements = Components.Elements;
                    /**
   * All attributes related with A11y.
   *
   * @type {string[]}
   */ var allAttributes = [
                        ARIA_HIDDEN,
                        TAB_INDEX,
                        ARIA_CONTROLS,
                        ARIA_LABEL,
                        ARIA_CURRENRT,
                        'role'
                    ];
                    /**
   * A11y component object.
   *
   * @type {Object}
   */ var A11y = {
                        /**
     * Required only when the accessibility option is true.
     *
     * @type {boolean}
     */ required: Splide.options.accessibility,
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            Splide.on('visible', function(Slide) {
                                updateSlide(Slide.slide, true);
                            }).on('hidden', function(Slide) {
                                updateSlide(Slide.slide, false);
                            }).on('arrows:mounted', initArrows).on('arrows:updated', updateArrows).on('pagination:mounted', initPagination).on('pagination:updated', updatePagination).on('refresh', function() {
                                removeAttribute(Components.Clones.clones, allAttributes);
                            });
                            if (Splide.options.isNavigation) {
                                Splide.on('navigation:mounted navigation:updated', initNavigation).on('active', function(Slide) {
                                    updateNavigation(Slide, true);
                                }).on('inactive', function(Slide) {
                                    updateNavigation(Slide, false);
                                });
                            }
                            initAutoplay();
                        },
                        /**
     * Destroy.
     */ destroy: function destroy() {
                            var Arrows = Components.Arrows;
                            var arrows = Arrows ? Arrows.arrows : {};
                            removeAttribute(Elements.slides.concat([
                                arrows.prev,
                                arrows.next,
                                Elements.play,
                                Elements.pause
                            ]), allAttributes);
                        }
                    };
                    /**
   * Update slide attributes when it gets visible or hidden.
   *
   * @param {Element} slide   - A slide element.
   * @param {Boolean} visible - True when the slide gets visible, or false when hidden.
   */ function updateSlide(slide, visible) {
                        setAttribute(slide, ARIA_HIDDEN, !visible);
                        if (Splide.options.slideFocus) {
                            setAttribute(slide, TAB_INDEX, visible ? 0 : -1);
                        }
                    }
                    /**
   * Initialize arrows if they are available.
   * Append screen reader elements and add aria-controls attribute.
   *
   * @param {Element} prev - Previous arrow element.
   * @param {Element} next - Next arrow element.
   */ function initArrows(prev, next) {
                        var controls = Elements.track.id;
                        setAttribute(prev, ARIA_CONTROLS, controls);
                        setAttribute(next, ARIA_CONTROLS, controls);
                    }
                    /**
   * Update arrow attributes.
   *
   * @param {Element} prev      - Previous arrow element.
   * @param {Element} next      - Next arrow element.
   * @param {number}  prevIndex - Previous slide index or -1 when there is no precede slide.
   * @param {number}  nextIndex - Next slide index or -1 when there is no next slide.
   */ function updateArrows(prev, next, prevIndex, nextIndex) {
                        var index = Splide.index;
                        var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;
                        var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;
                        setAttribute(prev, ARIA_LABEL, prevLabel);
                        setAttribute(next, ARIA_LABEL, nextLabel);
                    }
                    /**
   * Initialize pagination if it's available.
   * Append a screen reader element and add aria-controls/label attribute to each item.
   *
   * @param {Object} data       - Data object containing all items.
   * @param {Object} activeItem - An initial active item.
   */ function initPagination(data, activeItem) {
                        if (activeItem) {
                            setAttribute(activeItem.button, ARIA_CURRENRT, true);
                        }
                        data.items.forEach(function(item) {
                            var options = Splide.options;
                            var text = options.focus === false && options.perPage > 1 ? i18n.pageX : i18n.slideX;
                            var label = sprintf(text, item.page + 1);
                            var button = item.button;
                            var controls = item.Slides.map(function(Slide) {
                                return Slide.slide.id;
                            });
                            setAttribute(button, ARIA_CONTROLS, controls.join(' '));
                            setAttribute(button, ARIA_LABEL, label);
                        });
                    }
                    /**
   * Update pagination attributes.
   *
   * @param {Object}  data - Data object containing all items.
   * @param {Element} prev - A previous active element.
   * @param {Element} curr - A current active element.
   */ function updatePagination(data, prev, curr) {
                        if (prev) {
                            removeAttribute(prev.button, ARIA_CURRENRT);
                        }
                        if (curr) {
                            setAttribute(curr.button, ARIA_CURRENRT, true);
                        }
                    }
                    /**
   * Initialize autoplay buttons.
   */ function initAutoplay() {
                        [
                            'play',
                            'pause'
                        ].forEach(function(name) {
                            var elm = Elements[name];
                            if (elm) {
                                if (!isButton(elm)) {
                                    setAttribute(elm, 'role', 'button');
                                }
                                setAttribute(elm, ARIA_CONTROLS, Elements.track.id);
                                setAttribute(elm, ARIA_LABEL, i18n[name]);
                            }
                        });
                    }
                    /**
   * Initialize navigation slider.
   * Add button role, aria-label, aria-controls to slide elements and append screen reader text to them.
   *
   * @param {Splide} main - A main Splide instance.
   */ function initNavigation(main) {
                        Elements.each(function(Slide) {
                            var slide = Slide.slide;
                            var realIndex = Slide.realIndex;
                            if (!isButton(slide)) {
                                setAttribute(slide, 'role', 'button');
                            }
                            var slideIndex = realIndex > -1 ? realIndex : Slide.index;
                            var label = sprintf(i18n.slideX, slideIndex + 1);
                            var mainSlide = main.Components.Elements.getSlide(slideIndex);
                            setAttribute(slide, ARIA_LABEL, label);
                            if (mainSlide) {
                                setAttribute(slide, ARIA_CONTROLS, mainSlide.slide.id);
                            }
                        });
                    }
                    /**
   * Update navigation attributes.
   *
   * @param {Object}  Slide  - A target Slide object.
   * @param {boolean} active - True if the slide is active or false if inactive.
   */ function updateNavigation(_ref, active) {
                        var slide = _ref.slide;
                        if (active) {
                            setAttribute(slide, ARIA_CURRENRT, true);
                        } else {
                            removeAttribute(slide, ARIA_CURRENRT);
                        }
                    }
                    /**
   * Check if the given element is button or not.
   *
   * @param {Element} elm - An element to be checked.
   *
   * @return {boolean} - True if the given element is button.
   */ function isButton(elm) {
                        return elm.tagName === 'BUTTON';
                    }
                    return A11y;
                };
                ; // CONCATENATED MODULE: ./src/js/components/sync/index.js
                /**
 * The component for synchronizing a slider with another.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The event name for sync.
 *
 * @type {string}
 */ var SYNC_EVENT = 'move.sync';
                /**
 * The event names for click navigation.
 * @type {string}
 */ var CLICK_EVENTS = 'mouseup touchend';
                /**
 * The keys for triggering the navigation button.
 *
 * @type {String[]}
 */ var TRIGGER_KEYS = [
                    ' ',
                    'Enter',
                    'Spacebar'
                ];
                /**
 * The component for synchronizing a slider with another.
 *
 * @param {Splide} Splide - A Splide instance.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const sync = function(Splide) {
                    /**
   * Keep the sibling Splide instance.
   *
   * @type {Splide}
   */ var sibling = Splide.sibling;
                    /**
   * Whether the sibling slider is navigation or not.
   *
   * @type {Splide|boolean}
   */ var isNavigation = sibling && sibling.options.isNavigation;
                    /**
   * Layout component object.
   *
   * @type {Object}
   */ var Sync = {
                        /**
     * Required only when the sub slider is available.
     *
     * @type {boolean}
     */ required: !!sibling,
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            syncMain();
                            syncSibling();
                            if (isNavigation) {
                                bind();
                                Splide.on('refresh', function() {
                                    setTimeout(function() {
                                        bind();
                                        sibling.emit('navigation:updated', Splide);
                                    });
                                });
                            }
                        },
                        /**
     * Called after all components are mounted.
     */ mounted: function mounted() {
                            if (isNavigation) {
                                sibling.emit('navigation:mounted', Splide);
                            }
                        }
                    };
                    /**
   * Listen the primary slider event to move secondary one.
   * Must unbind a handler at first to avoid infinite loop.
   */ function syncMain() {
                        Splide.on(SYNC_EVENT, function(newIndex, prevIndex, destIndex) {
                            sibling.off(SYNC_EVENT).go(sibling.is(LOOP) ? destIndex : newIndex, false);
                            syncSibling();
                        });
                    }
                    /**
   * Listen the secondary slider event to move primary one.
   * Must unbind a handler at first to avoid infinite loop.
   */ function syncSibling() {
                        sibling.on(SYNC_EVENT, function(newIndex, prevIndex, destIndex) {
                            Splide.off(SYNC_EVENT).go(Splide.is(LOOP) ? destIndex : newIndex, false);
                            syncMain();
                        });
                    }
                    /**
   * Listen some events on each slide.
   */ function bind() {
                        sibling.Components.Elements.each(function(_ref) {
                            var slide = _ref.slide, index = _ref.index;
                            /*
       * Listen mouseup and touchend events to handle click.
       */ Splide.off(CLICK_EVENTS, slide).on(CLICK_EVENTS, function(e) {
                                // Ignore a middle or right click.
                                if (!e.button || e.button === 0) {
                                    moveSibling(index);
                                }
                            }, slide);
                            /*
       * Subscribe keyup to handle Enter and Space key.
       * Note that Array.includes is not supported by IE.
       */ Splide.off('keyup', slide).on('keyup', function(e) {
                                if (TRIGGER_KEYS.indexOf(e.key) > -1) {
                                    e.preventDefault();
                                    moveSibling(index);
                                }
                            }, slide, {
                                passive: false
                            });
                        });
                    }
                    /**
   * Move the sibling to the given index.
   * Need to check "IDLE" status because slides can be moving by Drag component.
   *
   * @param {number} index - Target index.
   */ function moveSibling(index) {
                        if (Splide.State.is(IDLE)) {
                            sibling.go(index);
                        }
                    }
                    return Sync;
                };
                ; // CONCATENATED MODULE: ./src/js/components/breakpoints/index.js
                /**
 * The component for updating options according to a current window width.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Interval time for throttle.
 *
 * @type {number}
 */ var THROTTLE = 50;
                /**
 * The component for updating options according to a current window width.
 *
 * @param {Splide} Splide - A Splide instance.
 *
 * @return {Object} - The component object.
 */ /* harmony default export */ const breakpoints = function(Splide) {
                    /**
   * Store breakpoints.
   *
   * @type {Object|boolean}
   */ var breakpoints = Splide.options.breakpoints;
                    /**
   * The check function whose frequency of call is reduced.
   *
   * @type {Function}
   */ var throttledCheck = throttle(check, THROTTLE);
                    /**
   * Keep initial options.
   *
   * @type {Object}
   */ var initialOptions;
                    /**
   * An array containing objects of point and MediaQueryList.
   *
   * @type {Object[]}
   */ var map = [];
                    /**
   * Hold the previous breakpoint.
   *
   * @type {number|undefined}
   */ var prevPoint;
                    /**
   * Breakpoints component object.
   *
   * @type {Object}
   */ var Breakpoints = {
                        /**
     * Required only when the breakpoints definition is provided and browser supports matchMedia.
     *
     * @type {boolean}
     */ required: breakpoints && matchMedia,
                        /**
     * Called when the component is mounted.
     */ mount: function mount() {
                            map = Object.keys(breakpoints).sort(function(n, m) {
                                return +n - +m;
                            }).map(function(point) {
                                return {
                                    point: point,
                                    mql: matchMedia("(max-width:" + point + "px)")
                                };
                            });
                            /*
       * To keep monitoring resize event after destruction without "completely",
       * use native addEventListener instead of Splide.on.
       */ this.destroy(true);
                            addEventListener('resize', throttledCheck); // Keep initial options to apply them when no breakpoint matches.
                            initialOptions = Splide.options;
                            check();
                        },
                        /**
     * Destroy.
     *
     * @param {boolean} completely - Whether to destroy Splide completely.
     */ destroy: function destroy(completely) {
                            if (completely) {
                                removeEventListener('resize', throttledCheck);
                            }
                        }
                    };
                    /**
   * Check the breakpoint.
   */ function check() {
                        var point = getPoint();
                        if (point !== prevPoint) {
                            prevPoint = point;
                            var State = Splide.State;
                            var options = breakpoints[point] || initialOptions;
                            var destroy = options.destroy;
                            if (destroy) {
                                Splide.options = initialOptions;
                                Splide.destroy(destroy === 'completely');
                            } else {
                                if (State.is(DESTROYED)) {
                                    Splide.mount();
                                }
                                Splide.options = options;
                            }
                        }
                    }
                    /**
   * Return the breakpoint matching current window width.
   * Note that Array.prototype.find is not supported by IE.
   *
   * @return {number|string} - A breakpoint as number or string. -1 if no point matches.
   */ function getPoint() {
                        var item = map.filter(function(item) {
                            return item.mql.matches;
                        })[0];
                        return item ? item.point : -1;
                    }
                    return Breakpoints;
                };
                ; // CONCATENATED MODULE: ./src/js/components/index.js
                /**
 * Export components.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ var COMPLETE = {
                    Options: options,
                    Breakpoints: breakpoints,
                    Controller: controller,
                    Elements: components_elements,
                    Track: track,
                    Clones: clones,
                    Layout: layout,
                    Drag: drag,
                    Click: click,
                    Autoplay: autoplay,
                    Cover: cover,
                    Arrows: arrows,
                    Pagination: pagination,
                    LazyLoad: lazyload,
                    Keyboard: keyboard,
                    Sync: sync,
                    A11y: a11y
                };
                var LIGHT = {
                    Options: options,
                    Controller: controller,
                    Elements: components_elements,
                    Track: track,
                    Clones: clones,
                    Layout: layout,
                    Drag: drag,
                    Click: click,
                    Arrows: arrows,
                    Pagination: pagination,
                    A11y: a11y
                };
                ; // CONCATENATED MODULE: ./build/module/module.js
                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    subClass.__proto__ = superClass;
                }
                /**
 * Export Splide class for import.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * Export Splide class for import from other projects.
 */ var module_Splide = /*#__PURE__*/ function(_Core) {
                    _inheritsLoose(Splide, _Core);
                    function Splide(root, options) {
                        return _Core.call(this, root, options, COMPLETE) || this;
                    }
                    return Splide;
                }(Splide);
            /***/ }
        };
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __webpack_require__(moduleId) {
            /******/ // Check if module is in cache
            /******/ if (__webpack_module_cache__[moduleId]) {
                /******/ return __webpack_module_cache__[moduleId].exports;
            /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = __webpack_module_cache__[moduleId] = {
                /******/ // no module.id needed
                /******/ // no module.loaded needed
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId](module1, module1.exports, __webpack_require__);
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{
            /******/ // define getter functions for harmony exports
            /******/ __webpack_require__.d = (exports, definition)=>{
                /******/ for(var key in definition){
                    /******/ if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                        /******/ Object.defineProperty(exports, key, {
                            enumerable: true,
                            get: definition[key]
                        });
                    /******/ }
                /******/ }
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{
            /******/ __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
        /******/ })();
        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{
            /******/ // define __esModule on exports
            /******/ __webpack_require__.r = (exports)=>{
                /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                    /******/ Object.defineProperty(exports, Symbol.toStringTag, {
                        value: 'Module'
                    });
                /******/ }
                /******/ Object.defineProperty(exports, '__esModule', {
                    value: true
                });
            /******/ };
        /******/ })();
        /******/ /************************************************************************/ /******/ // module exports must be returned from runtime so entry inlining is disabled
        /******/ // startup
        /******/ // Load entry module and return exports
        /******/ return __webpack_require__(311);
    /******/ })();
});
}),
"[project]/node_modules/splide-nextjs/react-splide/dist/js/utils/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.noop = noop;
exports.classNames = classNames;
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}
/**
 * Utility functions.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * No operation.
 */ function noop() {}
/**
 * Join class names with/without condition.
 *
 * @param {string|Object} args - A class name itself or { className: condition } object.
 */ function classNames() {
    var names = [];
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    args.forEach(function(className) {
        if (!className) {
            return;
        }
        if (typeof className === 'string') {
            names.push(className);
        } else if (_typeof(className) === 'object') {
            Object.keys(className).forEach(function(key) {
                if (className[key]) {
                    names.push(key);
                }
            });
        }
    });
    return names.join(' ');
}
}),
"[project]/node_modules/splide-nextjs/react-splide/dist/js/constants/events.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EVENTS = void 0;
/**
 * Export event list.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ var EVENTS = [
    'mounted',
    'updated',
    'move',
    'moved',
    'drag',
    'dragged',
    'visible',
    'hidden',
    'active',
    'inactive',
    'click',
    'arrows:mounted',
    'arrows:updated',
    'pagination:mounted',
    'pagination:updated',
    'navigation:mounted',
    'autoplay:play',
    'autoplay:pause',
    'autoplay:playing',
    'lazyload:loaded'
];
exports.EVENTS = EVENTS;
}),
"[project]/node_modules/splide-nextjs/react-splide/dist/js/components/Splide.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = void 0;
var _react = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
var _splide = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/splide-nextjs/splide/dist/js/splide.esm.js [app-client] (ecmascript)"));
var _utils = __turbopack_context__.r("[project]/node_modules/splide-nextjs/react-splide/dist/js/utils/index.js [app-client] (ecmascript)");
var _events = __turbopack_context__.r("[project]/node_modules/splide-nextjs/react-splide/dist/js/constants/events.js [app-client] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
/**
 * The class for the Splide component.
 */ var Splide = /*#__PURE__*/ function(_React$Component) {
    _inherits(Splide, _React$Component);
    var _super = _createSuper(Splide);
    /**
   * Splide constructor.
   *
   * @param {Object}   props                     - Props.
   * @param {string}   props.id                  - Optional. Id attribute for the root element.
   * @param {string}   props.className           - Optional. Additional class name for the root element.
   * @param {boolean}  props.hasSliderWrapper    - Optional. Whether to wrap a track by a slider element.
   * @param {boolean}  props.hasAutoplayProgress - Optional. Whether to render progress bar for autoplay.
   * @param {boolean}  props.hasAutoplayControls - Optional. Whether to render play/pause button for autoplay.
   * @param {string}   props.playButtonLabel     - Optional. The label for the play button.
   * @param {string}   props.pauseButtonLabel    - Optional. The label for the pause button.
   * @param {function} props.renderControls      - Optional. A function to render custom controls.
   */ function Splide(props) {
        var _this;
        _classCallCheck(this, Splide);
        _this = _super.call(this, props);
        _this.splideRef = /*#__PURE__*/ _react["default"].createRef();
        return _this;
    }
    /**
   * Initialize Splide right after the component is mounted.
   */ _createClass(Splide, [
        {
            key: "componentDidMount",
            value: function componentDidMount() {
                var _this$props = this.props, _this$props$options = _this$props.options, options = _this$props$options === void 0 ? {} : _this$props$options, _this$props$Extension = _this$props.Extensions, Extensions = _this$props$Extension === void 0 ? {} : _this$props$Extension, _this$props$Transitio = _this$props.Transition, Transition = _this$props$Transitio === void 0 ? null : _this$props$Transitio;
                this.splide = new _splide["default"](this.splideRef.current, options);
                this.splide.mount(Extensions, Transition);
                this.bind();
            }
        },
        {
            key: "componentWillUnmount",
            value: function componentWillUnmount() {
                if (this.splide) {
                    this.splide.destroy();
                }
            }
        },
        {
            key: "componentDidUpdate",
            value: function componentDidUpdate() {
                this.splide.refresh();
            }
        },
        {
            key: "bind",
            value: function bind() {
                var _this2 = this;
                _events.EVENTS.forEach(function(event) {
                    var handler = 'on' + event.split(':').map(function(fragment) {
                        return fragment.charAt(0).toUpperCase() + fragment.slice(1);
                    }).join('');
                    if (typeof _this2.props[handler] === 'function') {
                        _this2.splide.on(event, function() {
                            var _this2$props;
                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                                args[_key] = arguments[_key];
                            }
                            (_this2$props = _this2.props)[handler].apply(_this2$props, [
                                _this2.splide
                            ].concat(args));
                        });
                    }
                });
            }
        },
        {
            key: "sync",
            value: function sync(splide) {
                if (this.splide) {
                    this.splide.sync(splide);
                    this.remount();
                }
            }
        },
        {
            key: "remount",
            value: function remount() {
                if (this.splide) {
                    this.splide.destroy();
                    this.splide.mount();
                    this.bind();
                }
            }
        },
        {
            key: "renderTrack",
            value: function renderTrack() {
                return /*#__PURE__*/ _react["default"].createElement("div", {
                    className: "splide__track"
                }, /*#__PURE__*/ _react["default"].createElement("ul", {
                    className: "splide__list"
                }, this.props.children));
            }
        },
        {
            key: "render",
            value: function render() {
                var _this$props2 = this.props, id = _this$props2.id, className = _this$props2.className, hasSliderWrapper = _this$props2.hasSliderWrapper, hasAutoplayProgress = _this$props2.hasAutoplayProgress, hasAutoplayControls = _this$props2.hasAutoplayControls, _this$props2$playButt = _this$props2.playButtonLabel, playButtonLabel = _this$props2$playButt === void 0 ? 'Play' : _this$props2$playButt, _this$props2$pauseBut = _this$props2.pauseButtonLabel, pauseButtonLabel = _this$props2$pauseBut === void 0 ? 'Pause' : _this$props2$pauseBut, _this$props2$renderCo = _this$props2.renderControls, renderControls = _this$props2$renderCo === void 0 ? _utils.noop : _this$props2$renderCo;
                return /*#__PURE__*/ _react["default"].createElement("div", {
                    id: id,
                    className: (0, _utils.classNames)('splide', className),
                    ref: this.splideRef
                }, hasSliderWrapper && /*#__PURE__*/ _react["default"].createElement("div", {
                    className: "splide__slider"
                }, this.renderTrack()), !hasSliderWrapper && this.renderTrack(), hasAutoplayProgress && /*#__PURE__*/ _react["default"].createElement("div", {
                    className: "splide__progress"
                }, /*#__PURE__*/ _react["default"].createElement("div", {
                    className: "splide__progress__bar"
                })), hasAutoplayControls && /*#__PURE__*/ _react["default"].createElement("div", {
                    className: "splide__autoplay"
                }, /*#__PURE__*/ _react["default"].createElement("button", {
                    className: "splide__play"
                }, playButtonLabel), /*#__PURE__*/ _react["default"].createElement("button", {
                    className: "splide__pause"
                }, pauseButtonLabel)), renderControls());
            }
        }
    ]);
    return Splide;
}(_react["default"].Component);
exports["default"] = Splide;
}),
"[project]/node_modules/splide-nextjs/react-splide/dist/js/components/SplideSlide.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports["default"] = void 0;
var _react = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
var _utils = __turbopack_context__.r("[project]/node_modules/splide-nextjs/react-splide/dist/js/utils/index.js [app-client] (ecmascript)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
/**
 * The component for each slide.
 *
 * @author    Naotoshi Fujita
 * @copyright Naotoshi Fujita. All rights reserved.
 */ /**
 * The component for each slide.
 *
 * @param {Object} props - Props.
 */ var _default = function _default(_ref) {
    var children = _ref.children, className = _ref.className;
    return /*#__PURE__*/ _react["default"].createElement("li", {
        className: (0, _utils.classNames)('splide__slide', className)
    }, children);
};
exports["default"] = _default;
}),
"[project]/node_modules/splide-nextjs/react-splide/dist/js/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Splide", {
    enumerable: true,
    get: function get() {
        return _Splide["default"];
    }
});
Object.defineProperty(exports, "SplideSlide", {
    enumerable: true,
    get: function get() {
        return _SplideSlide["default"];
    }
});
var _Splide = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/splide-nextjs/react-splide/dist/js/components/Splide.js [app-client] (ecmascript)"));
var _SplideSlide = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/splide-nextjs/react-splide/dist/js/components/SplideSlide.js [app-client] (ecmascript)"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
}),
"[project]/node_modules/clsx/dist/clsx.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clsx",
    ()=>clsx,
    "default",
    ()=>__TURBOPACK__default__export__
]);
function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
        var o = e.length;
        for(t = 0; t < o; t++)e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for(f in e)e[f] && (n && (n += " "), n += f);
    return n;
}
function clsx() {
    for(var e, t, f = 0, n = "", o = arguments.length; f < o; f++)(e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
}
const __TURBOPACK__default__export__ = clsx;
}),
]);

//# sourceMappingURL=node_modules_742c5ab9._.js.map